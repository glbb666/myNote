本题的要求是用两个**先进后出**的栈模拟一个**先进先出**的队列。

因为有两个栈，所以我们把这两个栈称为`stack1`，`stack2`

因为栈和队列的进的顺序都是一样的，只是出的顺序不一样，所以我们进都可以在`stack1`中进行完成。

但是出的顺序是不一样的。

比如 这里是一个队列 1234

如果把它放入`statck1`中，就会变成如下情况

![1601718624851](images/1601718624851.png)

如果我们要把它进行出队操作，本来需要出的是1，但是在栈顶的却是4。

此刻我们可以使用`stack2`，把位置顺序进行一个改变。

- 先把`stack1`中的内容依次弹出，`push`到`stack2`中
- 再弹出`stack2`的栈顶

此时就换了位置。

![1601719045591](images/1601719045591.png)

那如果我们此刻还想继续删除队列头部元素，应该怎么办呢？`stack2`中的元素2，3，4都是先入栈的元素，我们只要从`stack2`中弹出即可。

因此我们可以知道

- 入队：把元素插入`stack2`
- 出队：
  - `stack2`为空，把`stack1`中的元素依次弹出，`push`入`stack2`，再弹出`stack2`的栈顶元素
  - `stack2`不为空，直接弹出`stack2`中的元素即可