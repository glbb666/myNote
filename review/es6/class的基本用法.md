### 类的由来 

`class`写法**(1)让对象原型的写法更加清晰、(2)更像面向对象编程的语法**。

**类的数据类型就是函数**，类**必须使用`new`调用**，通过`new`命令生成对象实例时会自动调用`constructor`方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。

**类的所有普通方法都定义在类的`prototype`属性上面**，在类的实例上面调用方法，其实就是调用原型上的方法，类的普通方法内部的**this**指向类的实例，单独调用时可能报错，所以最好绑定作用域或使用箭头函数或是用proxy进行访问拦截。

**类的静态方法就是在方法名前加上`static`关键字，表示该方法不会被实例继承**，而是直接通过类来调用。类的静态方法内部的**this**指向类本身

**静态方法可以与非静态方法重名**

`Object.assign`方法可以很方便地一次向类添加多个方法。

Class 可以通过`extends`关键字实现继承，这里还要提一下**super**的指向

`super`作为函数调用时，代表**父类的构造函数**，**只能且必须**在子类的构造函数中**调用一次**，只有调用`super`之后，才可以使用`this`关键字，<font color='red'>super内部的this指向子类实例</font>

`super`作为对象

直接使用`super`

- `super`的指向：在普通方法中，指向父类的原型，在静态方法中，指向父类。

通过`super`调用父类方法，方法内部`this`的指向

- 在普通方法中指向子类实例，在静态方法中指向子类，

  💥注意：<font color='red'>如果通过`super`对某个属性赋值</font>，这时`super`指向等同于通过`super`调用父类方法，父类内部`this`的指向

Class同时存在两条继承链。

（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。`Object.getPrototypeOf`方法可以用来从子类上获取父类

（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。

另外，类的内部**所有定义的方法，都是不可枚举的**，这一点与 `ES5` 的行为不一致。

### 总结

**（1）严格模式**

类和模块的内部，**默认就是严格模式**，所以不需要使用`use strict`指定运行模式。

**（2）不存在提升**

**类不存在变量提升**（hoist），这是因为**必须保证子类在父类之后定义**。

**（3）继承的差别**

`ES5`的继承实质上是**先创建子类的实例对象**，然后再将父类的属性和方法添加到this上

`ES6`的继承有所不同，先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承


















