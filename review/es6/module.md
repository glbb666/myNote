#### `AMD`

前端模块采用同步方式来引入必会造成`UI`初始化过长，不利于用户体验

`AMD`是“异步模块定义” ，用于浏览器，需要在声明的时候指定所有的依赖，通过形参传递依赖到模块内容中。

#### `CMD`

用于服务器，它把模块作为一个对象，整体引入，输入时必须查找对象属性，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。
```javascript
// CommonJS模块
let { stat, exists, readFile } = require('fs');
// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
#### `esModule`
`esModule`模块成为浏览器和服务器通用的模块解决方案。它的设计思想是尽量的静态化，**使得编译时就能确定模块的依赖关系，以及输入和输出的变量**。

`ES6` 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。 `ES6` 可以在编译时就完成模块加载。

```javascript
// ES6模块
import { stat, exists, readFile } from 'fs';
```

模块功能主要由两个命令构成：`export`命令用于规定模块的对外接口，在接口名与模块内部变量之间，必须建立一一对应的关系。`import`命令用于输入其他模块提供的功能。`import`命令输入的变量都是只读的，不允许在加载模块的脚本里面，改写接口。

但是，如果`a`是一个对象，改写`a`的属性是允许的。

```javascript
import {a} from './xxx.js'
a.foo = 'hello'; // 合法操作
```

`import`命令具有提升效果，会提升到整个模块的头部，首先执行

如果多次重复执行同一句`import`语句，那么只会执行一次，而不会执行多次。

除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。注意，模块整体加载所在的那个对象（上例是`circle`），应该是可以静态分析的，所以不允许运行时改变。

## `commonJS `与` ESmodule`差异

- `commonJs`是被加载的时候运行，`esModule`是编译的时候运行，效率要比` CommonJS` 高，但是没法引用` ES6` 模块本身，因为它不是对象。
- `esModule`输出接口与对应的值动态绑定，所以可以取到模块内部实时的值。`commentJs`在第一次被加载时，会完整运行整个文件并输出一个对象的浅拷贝，缓存在内存中。下次加载文件时，直接从内存中取值。