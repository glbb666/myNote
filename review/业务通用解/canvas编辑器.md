# 一、核心定义

PPT Canvas 编辑器是一套 **前端可视化 PPT 编辑工具** ，核心目标是在浏览器中实现对 Office 的 OpenXML 格式 PPT 文件的「渲染 + 编辑」能力，技术底座是：

* **Canvas** ：作为核心绘图容器，负责所有 PPT 元素（形状、文字、图表、幻灯片背景等）的视觉呈现；
* **Vue** ：作为前端框架，管理 UI 交互、组件生命周期；
* **Pinia** ：作为状态管理工具，统一维护 PPT 编辑过程中的数据（如幻灯片结构、元素属性、编辑状态等）；
* 核心设计亮点： **分层架构 + 标准化事件系统** ，让各模块松耦合（互不依赖、易扩展），比如编辑层操作不会直接影响渲染层，而是通过事件通知渲染层更新。

# 二、三层职责划分（核心架构）

整个编辑器按「职责单一原则」拆分为三层，层级间通过事件通信，避免直接耦合：

| 层级   | 核心职责                                                                      | 补充说明                                                                                              |
| ------ | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| 编辑层 | 处理用户交互逻辑（如拖拽形状、修改文字、调整样式、添加动画、保存 / 导出 PPT） | 不直接操作 Canvas，仅处理「业务逻辑」：比如用户拖拽元素后，更新数据模型，再通过事件通知渲染层重绘     |
| UI 层  | 提供编辑界面（如工具栏、侧边栏、属性面板、幻灯片缩略图、弹窗等）              | 纯视觉交互层，仅负责「展示 UI + 转发用户操作」到编辑层，比如点击 “加粗” 按钮，UI 层仅通知编辑层处理 |
| 渲染层 | 负责 Canvas 绘制和视觉呈现（核心层）                                          | 接收编辑层 / UI 层的事件，将 PPT 数据模型（幻灯片、形状、文字等）渲染到 Canvas 画布上                 |

# 三、渲染层

渲染层是整个编辑器的 “视觉核心”，所有 PPT 元素最终都通过这一层绘制到 Canvas 上，核心组件和引擎分工如下：

## 1. 核心组件

| 组件名         | 核心职责                           | 定位                                                                                     |
| -------------- | ---------------------------------- | ---------------------------------------------------------------------------------------- |
| CanvasControl  | 协调者（总指挥）                   | 不直接渲染，负责调度其他组件：比如通知 RenderEngine 绘制、通知 CanvasDocument 更新元素树 |
| RenderEngine   | 实际执行 Canvas 绘制（渲染执行者） | 渲染层的 “干活的人”，分拆为 SceneEngine 和 HitEngine 两个子引擎                        |
| CanvasDocument | 管理 Canvas 元素树                 | 维护 PPT 元素的层级、父子关系（如幻灯片包含哪些形状、形状包含哪些文字），给渲染提供数据  |
| CanvasView     | 管理视觉表现                       | 负责画布的网格、背景、标尺、参考线等基础视觉元素的绘制                                   |

## 2. 双引擎渲染设计（RenderEngine 的拆分）

为了兼顾「渲染效果」和「交互性能」，RenderEngine 拆分为两个子引擎，各司其职：

| 引擎名            | 核心职责                 | 适用场景                                  | 关键特性                                                             |
| ----------------- | ------------------------ | ----------------------------------------- | -------------------------------------------------------------------- |
| CanvasSceneEngine | 场景渲染引擎（美观渲染） | 正常展示 PPT 时的视觉渲染                 | 支持抗锯齿、阴影 / 渐变、特效等，追求视觉还原 Office 效果            |
| CanvasHitEngine   | 命中检测引擎（快速渲染） | 用户交互时的命中检测（如点击 / 拖拽元素） | 仅用纯色编码渲染（无特效），速度极快，用于快速判断用户操作的目标元素 |

 **双引擎协作逻辑** ：

场景渲染引擎和命中检测引擎并非独立工作，而是 **共享渲染器注册体系** ：

* 当为某类元素（如形状、文本）注册「渲染器」时，该渲染器会同时被注册到两个引擎；
* 区别仅在于：
  * 场景引擎调用渲染器时，执行「带样式 / 特效的美观渲染逻辑」；
  * 命中引擎调用渲染器时，执行「唯一纯色编码的极简渲染逻辑」（仅用于命中检测，无样式）。

## 3. 元素渲染层（ElementRenderer）—— 渲染逻辑的最小单元

| 维度     | 核心信息                                                                                                                                                            |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 本质     | 各类 PPT 元素（形状 / 图片 / 文本 / 图表等）的「渲染逻辑实现体」                                                                                                    |
| 存储位置 | `modules/canvas-renderer-engine/src/elements/`目录（按元素类型分文件，如 `shape-renderer.ts`、`text-renderer.ts`）                                            |
| 调度方式 | 通过 `RenderRegistry`（渲染注册表）实现「按类型分发」：`renderRegistry.getRenderer(element.type)?.render(ctx, element)`（根据元素类型找到对应渲染器，执行渲染） |
| 核心作用 | 把 “渲染层模型” 转化为 Canvas 可绘制的指令（比如形状渲染器会解析形状的路径、填充色、描边，调用 `ctx.fill()`/`ctx.stroke()`绘制）                              |

## 4. 渲染文档（CanvasDocument）—— 渲染层的 “数据管家”

* 核心职责：维护渲染层的「元素树模型」（基于编辑层模型转换而来，包含元素的位置、尺寸、样式、层级等渲染所需的所有信息）；
* 作用：给渲染引擎提供 “绘制数据源”，比如渲染某张幻灯片时，CanvasDocument 会把该幻灯片下的所有元素按层级、类型整理好，供引擎调用对应渲染器。

## 5. 控制器调度层（CanvasController）—— 渲染流程的 “总指挥”

* 核心职责：统筹整个渲染链路（从 “数据准备” 到 “双引擎调用” 再到 “画布绘制”），不做具体渲染操作，只负责 “调度顺序和逻辑”；
* 比如：触发页面重绘时，CanvasController 会先通知 CanvasDocument 更新元素模型，再通知双引擎按规则渲染，最后处理画布的层级 / 合成。

## 6. 双画布结构（Canvas 双画布）—— 交互性能的核心设计

Canvas 并非单画布，而是「主画布 + 命中画布」的双画布结构：

* **主画布** ：用户可见的画布，由场景渲染引擎绘制（带样式、特效、抗锯齿，视觉和 Office 一致）；
* **命中画布** ：隐藏的离屏画布（用户看不到），由命中检测引擎绘制（仅纯色编码，无样式）；
* 核心目的：避免在 “用户交互（点击 / 拖拽）” 时，对主画布做复杂的像素检测，而是通过隐藏的命中画布快速定位元素。

## 7. 渲染流程

第一步：渲染形状（完整渲染链路）

```
后端Ooxml SDK 
  │ 遍历XML标签，提取幻灯片元素数据
  ▼
编辑层 
  │ 1. 构建形状的编辑数据模型；2. 继承主题样式（字体/颜色/描边）
  ▼
渲染层 
  │ 转换为渲染专属模型（计算旋转/平移/画布坐标/层级）
  ▼
CanvasController（总指挥）
  │ 调度CanvasDocument整理元素数据
  ▼
CanvasDocument 
  │ 维护渲染层元素树，按类型+层级排序
  ▼
RenderRegistry（渲染注册表）
  │ 调用 renderRegistry.getRenderer(element.type) 匹配形状渲染器
  ▼
形状渲染器（ElementRenderer）
  │ ├─ 分支1：调用场景渲染引擎 → 绘制带样式/特效的形状
  │ │   ▼
  │ │ 主画布（用户可见：抗锯齿+阴影+渐变）
  │ │
  │ └─ 分支2：调用命中检测引擎 → 用唯一纯色绘制形状
  │     ▼
  │    命中画布（用户隐藏：纯色编码，无任何样式）
  ▼
最终效果：用户在主画布看到渲染完成的形状
```

第二步：移动形状 交互链路

```
用户操作（点击/拖拽画布）
  │ 获取鼠标当前坐标 (x,y)
  ▼
CanvasController（总指挥）
  │ 调度命中检测引擎，不操作主画布
  ▼
命中画布（隐藏）
  │ 读取坐标(x,y)对应的像素颜色值
  ▼
颜色-元素映射表
  │ 通过纯色编码匹配到目标形状的渲染模型ID
  ▼
CanvasDocument
  │ 定位目标形状的渲染模型，锁定元素
  ▼
编辑层
  │ 更新形状的编辑数据模型（修改x/y坐标）
  ▼
渲染层
  │ 同步更新渲染模型的画布坐标（重算位置）
  ▼
CanvasController（总指挥）
  │ 触发局部重绘指令，不重绘整张画布
  ▼
形状渲染器（ElementRenderer）
  │ ├─ 分支1：场景渲染引擎 → 按新坐标重绘带样式的形状
  │ │   ▼
  │ │ 主画布更新（形状移动到新位置）
  │ │
  │ └─ 分支2：命中检测引擎 → 按新坐标重绘纯色形状
  │     ▼
  │    命中画布同步更新（保证后续命中准确）
  ▼
最终效果：用户看到形状在主画布上移动
```

 **关键细节** ：

1. 命中检测的核心：隐藏的命中画布上，每个元素对应唯一纯色，鼠标点击位置的像素颜色就是 “元素标识”，无需遍历所有元素，检测速度极快；
2. 重绘逻辑：移动操作仅更新元素的渲染模型坐标，CanvasController 触发场景引擎重绘该元素（而非整个画布），保证交互流畅；
3. 双画布同步：主画布更新后，命中画布也会同步更新该元素的纯色位置，确保后续交互的命中准确性。

**核心总结:**

1. 渲染层的核心是「双引擎 + 双画布 + 元素渲染器」：双引擎负责 “美观渲染” 和 “快速命中”，双画布承载对应的绘制结果，元素渲染器是各类元素的具体绘制逻辑；
2. 渲染流程的核心是 “数据模型转换 + 控制器调度”：从后端 XML 数据→编辑层模型→渲染层模型，再由 CanvasController 调度双引擎完成绘制；
3. 交互（如移动形状）的核心是 “命中画布快速定位”：通过隐藏画布的纯色编码，避免复杂计算，兼顾交互性能和准确性。

# 四、问答

## 1. 编辑器模型和渲染层模型的区别

| 维度       | 编辑层模型                                                            | 渲染层模型                                                     |
| ---------- | --------------------------------------------------------------------- | -------------------------------------------------------------- |
| 核心目的   | 支撑 PPT 的「编辑操作」（写操作）                                     | 支撑 Canvas 的「视觉展示」（读操作）                           |
| 数据复杂度 | 复杂、完整（保留 OpenXML 全量信息）                                   | 扁平、精简（仅保留渲染所需信息）                               |
| 数据范围   | 包含展示 + 非展示信息（如超链接的 Office 版本号、延展信息、编辑历史） | 仅包含展示信息（如位置、尺寸、样式、路径，无冗余字段）         |
| 数据结构   | 层级深、关联多（如形状关联主题、动画、批注）                          | 扁平化（直接映射 Canvas 绘制指令，如 {x,y,width,height,fill}） |
| 核心操作   | 增删改查、数据校验、版本回溯                                          | 只读、快速解析、适配 Canvas API                                |

## 2. 为什么要分开构建？

* **性能优化** ：渲染层只关注 “绘制”，扁平模型能被 Canvas 引擎快速解析，避免渲染时解析复杂的编辑层数据（比如渲染一个矩形，不需要解析它的超链接版本号）；
* **职责隔离** ：编辑层专注 “业务逻辑”（如保存 / 导出 / 撤销），渲染层专注 “视觉呈现”，修改其中一层不影响另一层（比如优化渲染逻辑，无需改动编辑层的数据结构）；
* **数据安全** ：编辑层保留 OpenXML 全量信息，保证 PPT 导出时能还原原始格式；渲染层仅裁剪展示所需数据，避免无用数据占用内存、拖慢绘制速度。

## 3. 渲染的流程

前面是编辑➕渲染，这里是纯渲染流程，会更加细致

```
用户操作：拖拽形状 → 释放鼠标
  │ 触发画布交互组件的move事件
  ▼
控制器层：CanvasController
  │ 检测到元素position属性变化，提取原位置/新位置
  ▼
脏区管理层
  │ 调用_emitDirtyRegion() → 标记原位置、新位置为「脏区」（需要重绘的区域）
  ▼
智能合并逻辑
  │ 调用_calculateDirtyRegions() → 合并重叠脏区（避免重复重绘同一区域）
  ▼
协调层调度：CanvasRenderEngine
  │ 调用render() → 仅重绘脏区，而非整张画布
  ▼
元素渲染层：RenderRegistry
  │ 调用getRenderer('shape') → 匹配ShapeRenderer（形状渲染器）
  ▼
双引擎执行渲染
  │ ├─ 分支1：CanvasSceneEngine → 绘制带样式的形状（视觉渲染）
  │ │   ▼
  │ │ 主画布（用户可见）更新脏区的形状位置
  │ │
  │ └─ 分支2：CanvasHitEngine → 绘制纯色编码的形状（碰撞渲染）
  │     ▼
  │    命中画布（隐藏）同步更新脏区的纯色编码
  ▼
最终效果：用户看到形状移动到新位置，无全屏重绘卡顿
```

## 4. 缩略图是怎么和三层架构协作的？

A：

缩略图模块的核心协作逻辑是 **事件驱动的全链路响应** ，完全依托项目的标准化事件总线和三层职责划分，实现了「编辑层数据变更→渲染层绘制更新→UI 层视图刷新」的自动化联动，具体流程如下：

1. **编辑层：触发数据变更事件**

   当用户在主画布执行「添加形状、移动元素、删除幻灯片」等操作时，编辑层的核心数据模型会首先更新。

   此时编辑层会通过 **标准化事件总线** ，发布一个带明确 Schema 的事件，比如：
   typescript

   运行

   ```
   // 事件示例（带Schema约束）
   {
     type: 'SLIDE_ELEMENT_UPDATED',
     payload: {
       slideId: 'slide-123', // 目标幻灯片ID
       elementId: 'shape-456', // 变更元素ID
       changes: { x: 100, y: 200 } // 具体变更内容
     },
     schemaVersion: '1.0'
   }
   ```

   这个事件只传递 “变更数据”，不关心后续谁来处理，完全符合三层松耦合的设计原则。
2. **渲染层：监听事件并执行缩略图绘制**

   渲染层的 `ThumbnailRenderService` 会提前订阅这类数据变更事件。

   收到事件后，它不会直接使用编辑层的复杂模型，而是做两件核心事：

   * 从 `CanvasDocument` 中获取对应幻灯片的 **渲染层扁平模型** （只包含缩略图绘制所需的位置、尺寸、样式，无冗余数据）；
   * 调用专属的 `ThumbnailRenderer`，在**离屏 Canvas** 上绘制缩略图（避免占用主画布资源）；
   * 绘制完成后，将离屏 Canvas 转换为 `Blob URL`（这也是我们内存管理策略的一部分），并发布一个 `THUMBNAIL_RENDERED` 事件，携带 `slideId` 和对应的 `blobUrl`。

   这里有两个关键优化点：一是复用了主渲染层的双引擎思路（缩略图也分 “视觉渲染” 和 “轻量命中”），二是通过 **脏区检测** ，只重绘变更的幻灯片缩略图，而非全部。
3. **UI 层：订阅绘制完成事件并刷新视图**

   UI 层的缩略图面板组件（Vue 组件）会订阅 `THUMBNAIL_RENDERED` 事件。

   收到事件后，组件会从 Pinia Store 中更新对应幻灯片的缩略图 `blobUrl`，并触发 DOM 刷新：
   vue

   ```
   <!-- 缩略图组件核心代码示例 -->
   <img 
     :src="slide.thumbnailBlobUrl" 
     :alt="slide.title"
     class="slide-thumbnail"
   />
   ```

   同时，UI 层还会处理缩略图的交互事件（比如点击缩略图切换幻灯片），此时会反向发布 `SLIDE_SWITCH` 事件，由编辑层响应并切换当前编辑的幻灯片，形成 **双向事件闭环** 。

## 5. 事件总线通信

整个协作过程中，三层之间没有任何直接的函数调用，完全通过事件总线通信。举个具体例子：用户拖拽主画布的一个矩形，编辑层发布位置变更事件 → 渲染层监听到事件，重绘对应幻灯片的缩略图 → UI 层的缩略图面板自动更新这个矩形的位置，全程无需手动同步数据，既保证了一致性，又实现了各层的职责隔离。
