### 缓存

#### 本地id缓存

读取值：

做法：当读取值的时候，如果缓存存在优先读缓存。缓存不存在则读文件，并用文件去设置缓存。

目的：读取缓存减少io操作，速度快。

更新值：

- 新增，分三种情况。

  - 当缓存和本地文件同时存在。两个都更新。
  - 当缓存不存在，更新本地文件，并把缓存设置为更新后的本地文件的值。
  - 当缓存和本地文件都不存在，同时更新。

    总结：当进行写操作的时候，必须保证文件和缓存都是最新的
- 删除

#### 元数据缓存

读取和更新的机制参考本地ID。

区别：

### 超出上限

新增数据时数据超过存储上限怎么办。

- 删除对应类型（创建或者收藏）最老的一个localId
- 删除localId对应的目录（一个目录包含1～n个文件，每个文件是一个切片）

### 文件

#### 本地id文件

类型：单个文件

数据格式：{

    [本地id]：云端id

}

#### 元数据文件

类型：在目录下，用本地id作为文件标识。

数据格式：包含分片上传的状态，未上传，上传中，已上传。

### 数据

元数据（切片信息）

#### **本地id**

创建：

数据格式：local+时间戳

产生时机：创建文件时产生

云端Id：

和服务交互时产生

#### **元数据**

产生时机：创建文件时产生

**脏队列缓存**

清除时机：进行单个文件或者多个文件上传的时候

**读取的文件目录**

本地id文件

### 工具方法

#### 初始化数据：

- 生成localId
- 初始化元数据
- 存储localId到映射中
- 异步生成云端id，更新映射（保证离线场景）

#### 保存具体切片数据

保存形式：切片上传

每个切片大小：128kb

保存方式：

- 从元数据中获取文件切片长度
- 根据localId获取文件目录
- 打开文件目录最新的一个文件
  - 当最新的文件不存在，创建一个新的文件，写入数据，更新元信息对应的切片状态为未上传
  - 当最新的文件存在
    - 文件大小大于等于阈值，创建一个新的文件，写入数据，更新元信息对应的切片状态为未上传
    - 文件大小小于阈值，写入文件
      - 写入成功，更新元信息对应的切片状态为未上传
      - 写入失败

**上传流程**

**上传单一数据**

上传时机：

**上传多数据**

做法：

清除脏队列缓存

问题：

#### 本地存储数据包

- 编辑
- 增量
- 收藏
  收藏的时候会设置localId

### **优化点**

1. **切片上传，用promise.all代替await的promise队列，每个切片都有标识，所以不存在乱序的现象。**
2. **上传的时候可以用promise.race替代promise.all：有一个成功就可以进行上传**

### **知识点**

#### **文件的切片上传**

端会告诉服务，有几片，然后把具有标识的片上传给服务。重复上传相同的片会发生覆盖，当服务接收到完整的片之后会进行拼接，拼接之后再下发。

##### **如何切片**

##### **如何上传**

##### **如何确定标识**
