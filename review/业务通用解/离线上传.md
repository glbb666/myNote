### 背景

用来记录用户轨迹的户外系统。解决了用户在户外信号不好的情况下无法记录轨迹的痛点。

支持离线状态下的查看，创建，编辑，上传。大文件上传，断点续传，并行上传。

解决了以下两个痛点：

1. 户外场景没有信号。
2. 录制数据过大软件崩溃闪退。

这个系统每次可以生产一个数据包，有一定体量。

用localId进行标识，记录在本地。

当有网情况下，会把本地localId替换成云端Id，并且把数据包的内容按一定优先级进行上传。

它包含以下内容：

### **元数据：**

一个对象。

对象的键为数据包的本地id，值为一个对象。结构如下

```javascript
{
	[localId]:{
		[数据包基本信息的上传状态]:boolean;
		[数据包切片的上传状态]:array;数组的每一项对应一个切片;
		[图片列表信息]:array;图片在本地存储的地址以及上传状态，如果上传成功，图片地址会被切换成云端地址。
	}
}
```

作用：记录所有数据包基本信息的上传状态，记录数据包切片的上传状态，数据包未上传图片的信息。

产生时机：创建数据包时初始化，修改基本信息时会更新，产生新切片时会更新，增删图片也会更新。

### 数据包组成

#### **本地id：**

作用：用来在本地标识数据，因为数据支持无网生成。

数据格式：local+时间戳

产生时机：创建数据包时产生

#### 云端Id：

作用：用来在云端表示数据

产生时机：和服务交互时产生

#### 基本信息数据

作用：记录包的基本信息，比如标题，创建人，修改时间等信息。

产生时机：创建数据，编辑数据的时候。

上传时机：

- 创建完成：点击结束记录的时候，会把基本数据直接进行上传（因为数据比较少）。接着根据上传是否成功，把上传状态写入元数据。
- 编辑完成：同上。
- 后台上传：当后台上传时，会检测元数据信息，按照基本信息，切片数据，图片的优先级进行上传。

#### 图片数据：

作用：记录数据包的图片信息。

产生时机：用户手动从本地图库添加。

上传时机：

- 创建时：

  - 有网时：通过图片组件添加。图片组件内部会检测图片路径是本地路径还是云端路径，如果是本地路径，会把图片自动上传到OSS服务。OSS服务会把图片压缩到最佳尺寸，返回一个云端地址。
  - 无网时，先把本地图片从图库复制到数据包相应的路径（避免用户删除的情况）。并且把图片文件里图片的路径设置为本地路径。
- 编辑时：同上
- 当点击保存时，会把地址存在本地，同时把已经存在云端的地址进行上传。（图片存在云端不代表图片地址传输给服务）
- 当上传成功时，会修改相应图片的状态为已上传。
- 后台上传：

  - 对于本地图片：会先把图片上传给服务，再把地址上传给服务。
  - 对于云端图片：直接上传给服务。

#### 文件具体数据：

作用：记录数据包的具体数据。

产生时机：

- 创建时：在本地记录数据时持续产生。

记录到本地时机：

- 当记录时间超过x秒钟，或者用户移动了几十米，会记录到内存中。
- 因为支持离线查看，所以当拉取云端数据，且云端id对应的mapid不存在的时候，会把云端的数据备份到本地。

记录形式：

切片。元数据中保存切片的上传状态。每个切片都会有标识，端把把具有标识的片上传给服务。重复上传相同的片会发生覆盖，当服务接收到完整的片之后会进行拼接，拼接之后再下发。

上传时机：

见下面的数据包上传器。

### 缓存

#### 本地id缓存

读取值：

做法：当读取值的时候，如果缓存存在优先读缓存。缓存不存在则读文件，并用文件去设置缓存。

目的：读取缓存减少io操作，速度快。

更新值：

- 新增，分三种情况。

  - 当缓存和本地文件同时存在。两个都更新。
  - 当缓存不存在，更新本地文件，并把缓存设置为更新后的本地文件的值。
  - 当缓存和本地文件都不存在，同时更新。

    总结：当进行写操作的时候，必须保证文件和缓存都是最新的
- 删除

#### 元数据缓存

读取和更新的机制参考本地ID。

#### 图片数据缓存

超出上限

新增数据时数据超过存储上限怎么办。

- 删除对应类型（创建或者收藏）最老的一个localId
- 删除localId对应的目录（一个目录包含1～n个文件，每个文件是一个切片）

### 文件

#### 本地id文件

类型：单个文件

本地id：local+时间戳，创建文件时产生

数据格式：{

    [本地id]：云端id

}

#### 元数据文件

类型：单个文件，在元数据目录下，用本地id作为文件标识。

数据格式：

- 基本数据的上传状态，未上传，已上传
- 分片上传的状态，未上传，上传中，已上传。
- id下未上传的图片路径

#### 基本信息文件

类型：单个文件，在基本信息目录下，用本地id作为文件标识。

数据格式：文件的基本信息，标题，修改时间等。

### 图片信息文件

类型：单个文件，在图片信息目录下，用本地id作为文件表示。

用来存储图片的地址

#### 文件具体信息目录

类型：单个目录，以localId命名文件目录。

##### 切片文件

类型：一个目录内的多个切片文件，

目录下存储切片文件。

##### 图片

未上传的本地文件存在这个目录下，这样可以避免本地图片在图库被删除的情况。

**脏队列缓存**

清除时机：进行单个文件或者多个文件上传的时候

**读取的文件目录**

本地id文件

### 数据的增删改查

#### 数据生产流程

##### 初始化数据

- 生成localId
- 初始化元数据
- 存储localId到映射中
- 异步生成云端id，更新映射（离线场景存在更新失败的情况）

以下步骤支持同时触发

##### 保存具体切片数据

数据来源：通过调用上游提供的监听事件获得数据

保存形式：文件切片

每个切片大小：128kb

保存方式：

- 从元数据中获取文件切片长度
- 根据localId获取文件目录
- 打开文件目录最新的一个文件
  - 当最新的文件不存在，创建一个新的文件，写入数据，更新元信息对应的切片状态为未上传
  - 当最新的文件存在
    - 文件大小大于等于阈值，创建一个新的文件，写入数据，更新元信息对应的切片状态为未上传
    - 文件大小小于阈值，写入文件
      - 写入成功，更新元信息对应的切片状态为未上传
      - 写入失败

#### 数据删除流程

##### 主动删除

- 有网
  - 有云端id，先删远程数据，删除成功之后再删本地数据。
  - 无云端id，直接删除本地数据
- 无网
  - 删除本地数据

##### 被动删除

被动删除有两种情况

- 在云端检测到数据被删除，会删除数据对应的本地包（可能是b用户删除的）
- 当本地的数据包超过最大数量，比如10，也会从最旧的进行清除

#### 数据更新

只有基本数据，如标题，修改时间等可以进行更新。

当数据一部分上传给服务，在其他设备就支持显示了。

此刻其他用户可修改标题等基本信息。

举个例子：假设用户a生产了数据，此刻用户b修改了数据。

那么用户a再拉取数据的时候，就需要对基本数据部分进行更新。

#### 数据展示流程

##### 数据包列表

在进入数据包列表时，先检测网络状况。

- 有网络，和服务请求数据，把服务请求的数据和本地的数据进行合并。本地的在前服务的在后。
- 无网，那就只展示本地的数据，这样能保证用户在离线状态下依然可以使用。

##### 数据包信息

在展示数据包信息时。

- 有网络，和服务请求数据，把服务请求的数据和本地的数据进行合并。优先以本地的数据为准。
  - 当服务的图片被判违规时就使用服务的图片数据。
- 无网，那就只展示本地的数据，这样能保证用户在离线状态下依然可以使用。

对于元数据：展示的是最新的

对于详情数据：会展示拼接完成后的。

## 上传流程（纯）

把任务创建，任务上传控制，任务上传器，拆分为三块通用且独立的逻辑。

- 通过**任务工厂**对不同类型的任务进行创建。
- 抽取了一个 **业务无关的上传器控制器** ，上传器控制器支持**添加不同类型的上传器，支持并行上传。**
- **上传器使用模版方法设计模式。** 以建设在利用不同类型的上传器不同类型的任务的能力。

### 任务工厂（任务创建）

任务使用任务工厂创建

```javascript
// 任务工厂，用于创建任务
function createTask(info:any, type:string) {
    return {
        info, 
        type
    };
}
```

其中 `type`用来匹配任务上传器，`info`是不同类型的任务。

### 上传器控制器（任务上传控制）

**是什么：**

是一个上传的控制器，用来进行任务的上传。支持并行上传，可支持配置最大并行上传数量，待上传任务数量等，支持加载/卸载不同的上传器。不同的上传器可以用来上传不同的任务。

有一个任务队列，可以增加新任务。

**为什么：**

做能力而不是做需求。上传器控制器抽取了上传过程中会发生的通用事件，支持在不同业务背景下的上传需求。

**怎么做：**

```javascript
class AdvancedUploadManager {
    constructor({ maxConcurrentUploads = 2, maxQueueSize = 10 }) {
        this.maxConcurrentUploads = maxConcurrentUploads;
        this.maxQueueSize = maxQueueSize;
        this.uploadMap = new Map(); // 存放不同类型的上传器
        this.queue = [];
        this.activeUploads = 0;
    }

    /**
     * 注册上传器
     * @param {string} type 任务类型
     * @param {Object} uploader 上传器对象，需要有upload方法
     */
    registerUploader(type, uploader) {
        this.uploadMap.set(type, uploader);
    }

    /**
     * 注销上传器
     * @param {string} type 任务类型
     */
    unregisterUploader(type) {
        if (this.uploadMap.has(type)) {
            this.uploadMap.delete(type);
            console.log(`注销上传器: 类型 ${type}`);
        } else {
            console.log(`未找到类型为 ${type} 的上传器，无法注销`);
        }
    }

    /**
     * 添加任务
     * @param {Object} task 任务对象，包含file和type
     */
    addTask(task) {
        if (this.queue.length >= this.maxQueueSize) {
            throw new Error('上传队列已满');
        }
        if (!this.uploadMap.has(task.type)) {
            throw new Error(`无法找到类型为 ${task.type} 的上传器`);
        }
        this.queue.push(task);
        console.log(`任务添加成功: ${task.file.name}, 类型: ${task.type}`);
    }

    startNextTask() {
        if (this.queue.length > 0 && this.activeUploads < this.maxConcurrentUploads) {
            const task = this.queue.shift();
            this.activeUploads++;
            this.processTask(task);
        }
    }

    /** 
     * 处理上传任务
    */
    async processTask(task) {
        try {
            const uploader = this.uploadMap.get(task.type);
            await uploader.upload(task.file);
            console.log(`上传成功: ${task.file.name}`);
        } catch (error) {
            console.error(`上传失败: ${task.file.name}, 错误: ${error}`);
        } finally {
            this.activeUploads--;
            this.startNextTask();
        }
    }

    /**
     * 开始上传队列
     */
    start() {
        console.log('开始上传...');
        while (this.activeUploads < this.maxConcurrentUploads && this.queue.length > 0) {
            this.startNextTask();
        }
    }
}

```

### 任务上传器

基础上传器

```javascript
class BaseUploader {
    async run(file) {
        try {
            await this.upload(file);
            this.onComplete(file);
        } catch (error) {
            this.onError(error, file);
        }
    }
  
    // 定义一个可以被子类重写的空实现的cancel方法
    cancel() {
        // 默认实现为空，子类可以根据需要重写此方法
    }
  
    onComplete(file) {
        console.log(`Upload complete for ${file.name}`);
    }
  
    // 子类可以选择重写cancel，onComplete和onError方法
    onCancel() {
        // 子类根据需要覆写取消时的行为
    }
  
    onError(error, file) {
        console.error(`Error uploading ${file.name}: ${error}`);
    }

    // 子类需要实现upload方法
    async upload(file) {
        throw new Error('Upload method must be implemented by subclasses.');
    }
}

```

对于定制化的业务，可以基于基础上传器进行拓展

```javascript
class ImageUploader extends BaseUploader {
    constructor() {
        super();
        this.requestId = null;
    }

    async upload(file) {
        // 实现上传逻辑
        this.requestId = await this.startAsyncUpload(file);
        console.log(`Uploading image with request ID: ${this.requestId}`);
        // 根据实际情况对上传进行处理，并正确设置requestId
    }

    // 假设需要特定的取消逻辑
    cancel() {
        if (this.requestId != null) {
	    //框架原生方法
            native.cancelRequest(this.requestId);
            this.requestId = null; // 清除requestId，避免重复取消
        }
    }
}
// 现在可以创建上传器实例，并使用run方法启动上传过程
// 例如，上传一个图像文件
const imageUploader = new ImageUploader();
imageUploader.run({ name: 'mountains.jpg' });

// 如果需要，可以调用cancel (在ImageUploader中重写了此方法)
imageUploader.cancel();
```

## 架构图

```javascript
        +------------------+                           
        |   TaskFactory    |                               
        +--------|---------+                              
                 | Creates                                 
                 |
                 V  
        +-------------+        +---------------------+  
        |  Task (A/B)  +-------> BusinessUploadController  
        +-------------+        +-----------|-----------+  
                                       Registers           |
                                          | Uses            |
                                          |                 |   
                                +------------------+     +--------+
                                |  UploadController  |     |  Uploader  |
                                +---------|-----------+     +-----|------+
                                          |  Handles Upload       | Template Method Pattern
                                          |                       |
                                 +--------|----------------------+-------+
                                 |        |                      |       |
                           +----------+  +-------+          +----------+  
                           |UploaderA|  |UploaderB|          |UploaderC|  
                           +----------+  +-------+          +----------+  
                           Concrete      Concrete          Concrete  
                           Uploader      Uploader          Uploader  



```

## 上传流程（业务）

### 数据包上传器（定制化）

调用上传器，在里面进行不同类型的任务的上传器的注册。

- 注册图片上传器
- 注册文件详情切片上传器

上传器用于处理任务，不同的上传器会拿到不同类型的任务。

#### 图片任务构造器

- 需要的信息：云端图片路径（如果本地路径是需要先本地图片->OSS服务），云端id等信息
- 上传成功之后

  - 把本地图片地址替换成云端地址
  - 把数据包中的本地图片删除
- 上传失败之后

  - 因为云端地址不存在上传失败：删除地址不存在的本地图片
  - 因为网络问题上传失败：把元数据的上传状态置为false，等待下次上传

#### 文件详情切片任务构造器

- 需要的信息：文件路径，云端id等信息
- 上传成功之后

  - 把本地元数据中的切片信息置为已上传
- 上传失败之后

  - 等待下次上传

#### 单个数据包上传

上传时机：文件详情

上传频次：定时器。进入页面开始上传，接着每30s上传一次。

上传方式：

- 清空之前所有的上传缓存
- 把获取到的最新的元数据设置到缓存中
- 获取最新的（编辑后最新值>缓存>本地文件）元数据，筛选出其中未上传的图片
- 把未上传图片设置到脏数据队列中
- 设置数据包和包内未上传图片的映射
- 检测元数据中文件具体数据切片的上传情况，把未上传的数据切片包装成任务塞进任务队列
- 把未上传的图片包装成任务塞进任务队列
- 启动上传器进行上传

  - 支持并行上传
  - 支持取消上传(全局requestId)

#### 多个数据包并行上传

- 上传时机：文件列表
- 使用Promise.allSettled的形式调用上传方法。

**为什么使用Promise.allSettled？**

因为Promise.allSettled可以得到所有切片文件的结果。

**如何进行失败处理**

对于上传成功的文件，会把它的上传状态进行变更。对于上传失败的文件，会放入上传失败列表中，下次再进行上传。

## 文件切片防篡改

文件切片使用的是 HTTPS协议。具体看HTTPS协议。

## 文件切片防止丢失

文件切片传输层采取的是TCP协议。具体看TCP协议。

## 大文件上传

**文件的大小有做限制吗？**

没有，因为这个是获取用户的行走的形点的数据，通过信息端去上报，最多录制12个小时。所以其实纯文字数据，并不会到达一个过大的量级。
而且这个东西其实就和微信聊天记录一样。有缓存，用户用起来就丝滑。当用户察觉数据过大，可以去做一个手动的清除。没有必要替用户考虑说占用了太大这种问题。

## 问题

1. 待上传队列空了之后怎么办
   1. 再去读取元数据文件，把它塞满。
