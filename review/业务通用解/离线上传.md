### 背景

一个户外系统。

支持离线上传，大文件上传，断点续传，并行上传。

解决了以下两个痛点：

1. 户外场景没有信号。
2. 录制数据过大软件崩溃闪退。

### 基础信息

一个数据包，它在本地生产，一次生产一个，有一定体量。

用localId进行标识，记录在本地。

当有网情况下，会把本地localId替换成云端Id，并且把文件具体数据进行上传。

### **元数据：**

一个对象。

对象的键为数据包的本地id，值为一个对象。结构如下

```javascript
{
	[localId]:{
		[数据包基本信息的上传状态]:boolean;
		[数据包切片的上传状态]:array;数组的每一项对应一个切片;
		[图片列表信息]:array;图片在本地存储的地址以及上传状态，如果上传成功，图片地址会被切换成云端地址。
	}
}
```

作用：记录所有数据包基本信息的上传状态，记录数据包切片的上传状态，数据包未上传图片的信息。

产生时机：创建数据包时初始化，修改基本信息时会更新，产生新切片时会更新，增删图片也会更新。

### 数据包组成

#### **本地id：**

作用：用来在本地标识数据，因为数据支持无网生成。

数据格式：local+时间戳

产生时机：创建数据包时产生

#### 云端Id：

作用：用来在云端表示数据

产生时机：和服务交互时产生

#### 基本信息数据

作用：记录包的基本信息，比如标题，创建人，修改时间等信息。

产生时机：创建数据，编辑数据的时候。

上传时机：

- 当点击结束记录的时候。
- 当结束编辑的时候。
- 当上传切片数据的时候。

元数据中存着一个已上传云端标识

- 上传到云端成功，会把本地和云端元信息的已上传状态置为true。
- 当本地的已上传标识为false，说明之前的基本信息都是离线数据，没有成功上传到云端。
  - 上传本地文件具体数据切片时，如果监测到标识为false，会先把基本数据上传。

#### **元数据：**

作用：记录基本信息的上传状态，记录数据包切片的上传状态，未上传图片的信息。

产生时机：创建数据包时初始化，产生新切片时会更新，添加新图片也会更新。

#### 图片数据：

作用：记录数据包的图片信息。

产生时机：用户手动添加，每次添加完成之后确定，本地的图片信息都会被更改为最新的。

上传时机：

- 有网时，通过图片组件自动上传到服务，传给服务url
- 无网时，先把图片复制到数据包相应的路径，并且把meta里图片的状态置为未上传状态，下次上传时会检测本地未上传图片进行上传。

#### 文件具体数据：

作用：记录数据包的具体数据。

产生时机：

- 在本地记录数据时持续产生，会持续记录到内存中。
  - 记录到文件时机：当记录时间或者记录数据的大小达到一定量级。
- 因为支持离线查看，所以当拉取云端数据，且云端id对应的mapid不存在的时候，会把云端的数据备份到本地。

记录形式：切片。元数据中保存切片的上传状态。每个切片都会有标识，端把把具有标识的片上传给服务。重复上传相同的片会发生覆盖，当服务接收到完整的片之后会进行拼接，拼接之后再下发。

上传给服务时机：见下面的数据包上传器。

### 缓存

#### 本地id缓存

读取值：

做法：当读取值的时候，如果缓存存在优先读缓存。缓存不存在则读文件，并用文件去设置缓存。

目的：读取缓存减少io操作，速度快。

更新值：

- 新增，分三种情况。

  - 当缓存和本地文件同时存在。两个都更新。
  - 当缓存不存在，更新本地文件，并把缓存设置为更新后的本地文件的值。
  - 当缓存和本地文件都不存在，同时更新。

    总结：当进行写操作的时候，必须保证文件和缓存都是最新的
- 删除

#### 元数据缓存

读取和更新的机制参考本地ID。

#### 图片数据缓存

超出上限

新增数据时数据超过存储上限怎么办。

- 删除对应类型（创建或者收藏）最老的一个localId
- 删除localId对应的目录（一个目录包含1～n个文件，每个文件是一个切片）

### 文件

#### 本地id文件

类型：单个文件

本地id：local+时间戳，创建文件时产生

数据格式：{

    [本地id]：云端id

}

#### 元数据文件

类型：单个文件，在元数据目录下，用本地id作为文件标识。

数据格式：

- 基本数据的上传状态，未上传，已上传
- 分片上传的状态，未上传，上传中，已上传。
- id下未上传的图片路径

#### 基本信息文件

类型：单个文件，在基本信息目录下，用本地id作为文件标识。

数据格式：文件的基本信息，标题，修改时间等。

### 图片信息文件

类型：单个文件，在图片信息目录下，用本地id作为文件表示。

用来存储图片的地址

#### 文件具体信息目录

类型：单个目录，以localId命名文件目录。

##### 切片文件

类型：一个目录内的多个切片文件，

目录下存储切片文件。

##### 图片

未上传的本地文件存在这个目录下

**脏队列缓存**

清除时机：进行单个文件或者多个文件上传的时候

**读取的文件目录**

本地id文件

### 数据的增删改查

#### 数据生产流程

##### 初始化数据

- 生成localId
- 初始化元数据
- 存储localId到映射中
- 异步生成云端id，更新映射（离线场景存在更新失败的情况）

以下步骤支持同时触发

##### 编辑元数据

数据来源：用户输入

用户可以编辑元数据的信息，包含标题等独立于文件详情数据的一些数据。

##### 保存具体切片数据

数据来源：通过调用上游提供的监听事件获得数据

保存形式：文件切片

每个切片大小：128kb

保存方式：

- 从元数据中获取文件切片长度
- 根据localId获取文件目录
- 打开文件目录最新的一个文件
  - 当最新的文件不存在，创建一个新的文件，写入数据，更新元信息对应的切片状态为未上传
  - 当最新的文件存在
    - 文件大小大于等于阈值，创建一个新的文件，写入数据，更新元信息对应的切片状态为未上传
    - 文件大小小于阈值，写入文件
      - 写入成功，更新元信息对应的切片状态为未上传
      - 写入失败

#### 数据删除流程

##### 主动删除

- 有网
  - 是云端id，先删远程数据，删除成功之后再删本地数据。
  - 是本地id，删除本地数据
- 无网
  - 删除本地数据

##### 被动删除

被动删除有两种情况

- 在云端检测到数据被删除，会删除数据对应的本地包（可能是b用户删除的）
- 当本地的数据包超过最大数量，比如10，也会从最旧的进行清除

#### 数据增量更新

只有基本数据，如标题，修改时间等可以进行增量更新。

当数据一部分上传给服务，在其他设备就支持显示了。

此刻其他用户可修改标题等基本信息。

举个例子：假设用户a生产了数据，此刻用户b修改了数据。

那么用户a再拉取数据的时候，就需要对基本数据部分进行增量更新。

#### 数据展示流程

##### 数据包列表

在进入数据包列表时，先检测网络状况。

- 有网络，和服务请求数据，把服务请求的数据和本地的数据进行合并。本地的在前服务的在后。
- 无网，那就只展示本地的数据，这样能保证用户在离线状态下依然可以使用。

##### 数据包信息

在展示数据包信息时。

- 有网络，和服务请求数据，把服务请求的数据和本地的数据进行合并。优先以本地的数据为准。
  - 当服务的图片被判违规时就使用服务的图片数据。
- 无网，那就只展示本地的数据，这样能保证用户在离线状态下依然可以使用。

对于元数据：展示的是最新的

对于详情数据：会展示拼接完成后的。

#### 数据上传流程

获取本地的未上传数据。

**上传单一数据**

上传时机：

**上传多数据**

做法：

清除脏队列缓存

问题：

#### 本地存储数据包

- 编辑
- 增量
- 收藏
  收藏的时候会设置localId

### **优化点**

1. **切片上传，用promise.all代替await的promise队列，每个切片都有标识，所以不存在乱序的现象。**
2. **上传的时候可以用promise.race替代promise.all：有一个成功就可以进行上传**

### 脏数据队列

- 未上传图片队列
- 数据包和包内未上传图片的映射

### 上传器（纯组件）

包含的属性

- 待上传任务（任务有多种类型）
- 数据最大上传数量

包含的方法

- 添加任务的方法：使用不同的任务构造器构造不同类型的任务
- 开始上传任务方法
- 注册某种类型任务的构造器
- 注销某种类型任务的构造器

### 数据包上传器（定制化）

调用上传器，在里面进行不同类型的任务的上传器的注册。

- 注册图片上传器
- 注册文件详情切片上传器

上传器用于处理任务，不同的上传器会拿到不同类型的任务。

#### 图片任务构造器

- 需要的信息：图片路径，云端id等信息
- 上传成功之后

  - 把本地图片地址替换成云端地址
  - 把数据包中的本地图片删除
- 上传失败之后

  - 因为地址不存在上传失败：删除地址不存在的本地图片

#### 文件详情切片任务构造器

- 需要的信息：文件路径，云端id等信息
- 上传成功之后

  - 把本地元数据中的切片信息置为已上传
- 上传失败之后

#### 单个数据包上传

上传时机：文件详情

上传频次：定时器。进入页面开始上传，接着每30s上传一次。

上传方式：

- 清空之前所有的上传缓存
- 把获取到的最新的元数据设置到缓存中
- 获取最新的（编辑后最新值>缓存>本地文件）元数据，筛选出其中未上传的图片
- 把未上传图片设置到脏数据队列中
- 设置数据包和包内未上传图片的映射
- 检测元数据中文件具体数据切片的上传情况，把未上传的数据切片包装成任务塞进任务队列
- 把未上传的图片包装成任务塞进任务队列
- 启动上传器进行上传

  - 支持并行上传
  - 支持取消上传(全局requestId)

#### 多个数据包上传

- 上传时机：文件列表
