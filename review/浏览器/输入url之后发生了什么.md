## 大致流程

1. 主进程：浏览器的主进程捕获URL，将URL请求发送到专门的网络进程。
2. 网络进程获取IP（详情见DNS解析）：网络进程查询 本地缓存=>host文件=>DNS服务器 获取URL对应的IP地址（如果输入的是IP地址，此步骤省略）
3. 网络进程根据IP建立TCP 连接：建立TCP 连接（三次握手），对于HTTPS连接，会额外执行SSL握手。
4. 网络进程通过建立的连接向服务器发起HTTP请求
5. 网络进程：服务器处理HTTP请求，浏览器接受响应，收集响应数据（HTML、图像、CSS、JavaScript等
6. 网络进程将收到的资源传递给浏览器的主进程
7. 主进程接着将这些数据发送给一个或多个渲染进程。
8. 渲染进程渲染
9. 关闭TCP连接（四次挥手）

## 一、DNS 解析获取对应IP

寻找ip的顺序

- 缓存中：浏览器缓存=>操作系统缓存=>路由器缓存，如果没有缓存或缓存已过期
- 本机的 `hosts`文件
- DNS服务器：如果**本地 DNS 服务器**没有缓存，需要采用递归或者迭代查询的方式依次向**根域名服务器**、**顶级域名服务器**、**权威域名服务器**发起查询请求

> DNS解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢。
>
> DNS-prefetch会在后台预先解析页面上的域名，浏览器可以提前获取IP地址，从而减少请求资源时的延迟，加快页面的加载速度。
>
> 启用：`<link rel="dns-prefetch" href="//example.com">`。

## 二、根据IP建立TCP 连接（三次握手）

1. 客户端把一个 `标志位SYN`置为1，序号为随机值J**的数据包发送到服务器，请求建立连接，同时客户端进入** `syn_sent`半打开状态，等待服务器确认
2. 服务端收到数据包后由 `标志位SYN`=1**知道客户端请求建立连接，服务端进入** `syn_rcvd`**半打开状态。服务端将一个** `标志位SYN和ACK`都置为1，ack=J+1，序列号为随机值K**的数据包发送给客户端，以确认连接请求
3. 客户端接收到服务器的SYN+ACK包，检查ack是否为J+1，ACK是否为1，如果正确，客户端进入**`establish`**状态。接着，客户端将一个** `标志位ACK置为1`，ack=K+1**的数据包发送给服务端。
4. 服务端接收到确认后，检查ack是否为K+1，ACK是否为1，如果正确，服务端变为**`establish`**状态。连接建立成功。

![img](http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png)

![img](https://github.com/glbb666/myNote/blob/master/review/网络安全/image/tcp1.png)

> SYN:synchronous   建立连接
> ACK:acknowledgement  确认
> SYN_SENT:请求连接
> SYN_RECV:服务端被动打开后，接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。

**syn_sent**是主动打开方的「半打开」状态，**syn_rcvd**是被动打开方的「半打开」状态。**客户端是主动打开方，服务器是被动打开方**。

💥注意：**tcp在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送**。

## 三、发起HTTP请求

浏览器会根据解析出的 `IP`地址+端口，构建HTTP请求报文，这个请求报文由三部分组成: **请求行**, **请求头**和**请求正文**，并将http请求封装在一个tcp包中，这个tcp包将依次经过**传输层，网络层，数据链路层，物理层**到达服务器。

#### 请求行

`Method Request-URL HTTP-Version CRLF`

```
eg: GET index.html HTTP/1.1
```

常用的方法有: `GET`,` POST`, `PUT`,` DELETE`,` OPTIONS`, `HEAD`。

🌟`GET`和 `POST`有什么区别？

#### 请求头

请求报头允许客户端向服务器传递请求的**附加信息**和**客户端自身的信息**。

常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。

#### 请求体

当使用 `POST`, `PUT`等方法时，通常需要客户端向服务器传递数据。这些**数据就储存在请求正文**中。在请求包头中有一些与请求正文相关的信息，例如: 现在的 `Web`应用通常采用 `Rest`架构，请求的数据格式一般为 `json`。这时就需要设置 `Content-Type: application/json`。

## 四、服务器接受HTTP请求，浏览器响应

服务器会解析这个请求并作出响应，返回相应的资源给浏览器。HTTP响应报文也是由三部分组成: **状态码**, **响应头**和**响应报文**。

#### 状态码

状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。
  平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。

🌟301和302有什么区别？HTTP缓存？

#### 响应报头

常见的响应报头字段有: Server, Connection...。

#### 响应报文

服务器返回给浏览器的文本信息，通常 `HTML`, `CSS`,` JS`， 图片等文件就放在这一部分。

## 五、客户端渲染

详情在文档浏览器/浏览器的架构——渲染流程。

## 六、关闭TCP连接（四次挥手）

1. 客户端把一个**`标志位FIN`置为1，序号seq为随机值M**的数据包发送到服务器，用来关闭客户端到服务器的数据传送，客户端进入** `fin_wait_1`**状态
2. 服务器收到客户端的**`fin`**包，把一个** `标志位ACK置为1`，ack=M+1**的数据包发送给客户端，服务端进入** `close_wait`**状态
3. 客户端接收到服务器的**`ack`**包，检查** `ack`**是否为M+1，**`ACK`**是否为1，如果正确，客户端进入** `fin_wait_2`**状态
4. 服务器把一个**`标志位FIN`置为1，序号 `seq`为随机值N**的数据包发送到客户端，用来关闭服务器到客户端的数据传送，服务器进入到**last_ack**状态
5. 客户端收到服务器的fin包，把一个**`标志位ACK置为1`，ack=K+1**的数据包发送给客户端，客户端进入time_wait状态，在2MSL之后进入** `closed`**状态
6. 服务器收到客户端的包，进入**`closed`**状态

![img](http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png)
