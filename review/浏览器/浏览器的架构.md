## 浏览器的架构是什么

现代浏览器采用了多进程架构来增强性能和稳定性。每一个浏览器进程可以包含多个线程。

* 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
* 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

浏览器采用了多进程架构。

## 浏览器为什么要使用多进程架构

* 避免单个页面崩溃影响整个浏览器
* 避免第三方插件崩溃影响整个浏览器
* 充分利用多核优势：多进程架构允许浏览器将不同的任务分配到多个CPU核心中去执行。在单进程模型中，浏览器的所有任务都在一个进程中顺序执行，这就意味着即使你的计算机有多个核心，也只有一个核心在被使用，其他核心处于空闲状态。
* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。

> 内存等资源消耗也会更大，有点空间换时间的意思。

## 浏览器包含哪些进程

### 浏览器主进程（GUI进程）：（只有一个）

- 负责协调其他进程的创建和销毁，浏览器的其他进程都是GUI进程的子进程。
- 负责浏览器 UI 的显示，包括地址栏、书签栏、前进后退按钮等。
- 处理浏览器级别的任务，如文件下载、数据持久化等。
- 渲染进程生成的位图数据会被绘制到浏览器的窗口上，从而展现给用户看到的网页界面。

### **插件进程：（多个）**

* 每个插件对应一个进程

### **GPU进程：（最多一个）**

- CSS动画：处理CSS中定义的动画效果，如渐变、转换和3D变换等。
- WebGL渲染：WebGL是一种用于在Web浏览器中渲染3D图形的技术，它依赖于GPU进行高效的图形计算和渲染。
- 视频解码：浏览器中的视频播放通常会利用GPU来解码视频流，以减轻CPU的负担，提升播放性能。

> 如果没有使用到GPU进程的功能，是可以没有进程

### **网络进程**

在现代浏览器的多进程架构中，网络通信大多由专门的网络进程来负责。这包括网页内容、图片、CSS文件、JavaScript文件的下载，以及表单提交等。网络进程独立于渲染进程，可以服务于多个渲染进程，更高效地重用和共享网络缓存和会话数据。网络进程的沙盒化增强了网络操作的安全性。如果网络进程出现问题，它可以被单独重启，提高了稳定性。

### 渲染进程：（浏览器内核）

浏览器的每打开一个tab页，就会为其分配一个渲染进程。

每个渲染进程包含一个渲染引擎实例。渲染引擎是在渲染进程中运行的核心组件，负责解析 HTML、CSS、JavaScript，并将页面内容绘制到屏幕上。

如果一个渲染进程出现问题导致崩溃，只会影响到该进程正在渲染的标签页，而不会影响到其他标签页或整个浏览器。

- 每个标签页一般对应一个独立的渲染进程（相同站点可共享同一渲染进程）。
- 负责处理页面的渲染、JavaScript 执行和事件处理等。
- 采用沙盒环境，增加了安全性。

#### QA

**什么是沙盒**

沙盒模型是一种安全机制。在浏览器的上下文中，沙盒模型是用来隔离插件、渲染引擎或者整个浏览器标签页的进程，以提高浏览器的稳定性和安全性。

沙盒的主要特点是限制进程的能力和权限。在沙盒中运行的浏览器标签页或插件通常无法直接访问操作系统的文件系统，不能随意地读写文件，也不能与系统上运行的其他进程进行任意通信。这样，即使一个标签页或插件被恶意软件利用，恶意行为也被限制在沙盒内，减少了对用户数据和整个系统造成损害的风险。

**所有的进程都运行在沙盒中吗**

每个标签页、插件和扩展通常都会在自己的独立进程中运行，并且被沙盒化。沙盒化进程对于文件系统的访问和系统资源的访问都是受限的。

然而，并不是浏览器的所有进程都运行在沙盒中。一些核心的进程，例如负责用户界面的主进程或者网络进程，在某些情况下可能不会被沙盒化，因为它们需要更多的权限来完成任务。为了安全起见，这些进程会通过其他安全措施来进行保护，比如使用最小权限原则和安全编码实践。

## 渲染进程详细聊聊

对于普通的前端操作来说，最终要的是什么呢？答案是**渲染进程。**

### 渲染进程包含哪些线程：

1. **主线程** ：
   负责运行JavaScript，解析HTML生成DOM树，解析CSS生成CSSOM树，执行布局、绘制，处理DOM事件和用户交互等。**主线程运行JavaScrip和页面的渲染（布局和绘制）是互斥的，这里会用到事件循环机制进行调度**。(具体可以看目录下JS事件循环机制)
2. **合成线程**：
   合成线程是GUI进程的上游，主线程的下游。

   1. 上游主线程：在回流和重绘的时候，**主线程会生成合成树**，合成树包含页面的分层信息和如何处理分层的指令。
   2. 中游合成线程：根据合成树的信息来**创建合成帧**。这个过程包括各个独立层的合成，如图像的层叠、变换和合成。这样使得部分图像处理可以在主线程之外完成，减轻了主线程的负担，并有助于提高页面渲染的性能。
   3. 下游GPU进程：接收来自合成器的合成帧数据，通常包括纹理和绘制命令。会**执行最终的渲染操作**，将这些帧显示在屏幕上。
3. 事件处理线程

   监听各种事件（如用户输入、定时器、网络请求等），并根据事件类型将回调函数放入合适的任务队列中（宏任务队列或微任务队列）
4. 定时触发器线程

   1. `setInterval`与 `setTimeout`所在线程
   2. 浏览器定时计数器并不是由主线程的JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   3. 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
   4. 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. Web Worker线程

   1. 创建Worker时，JS引擎向浏览器申请开一个子线程
   2. JS引擎线程与worker线程间通过postMessage通信
   3. 更详细的参见浏览器目录/WebWorker&ServiceWorker&SharedWorker

#### QA

**为什么JS引擎是单线程的？**

1. **执行环境** ：最初的JavaScript执行环境（即早期网页浏览器）并未设计为执行复杂的计算任务，也未考虑到并发执行的需求。
2. **DOM安全** ：因为JavaScript可操作DOM，如果JavaScript是多线程的，那么可能就需要管理对于DOM的并发访问。这可能引发如两个线程同时修改同一个DOM节点的情况，造成不可预测的结果。

### 渲染进程和其他进程的交互的实例

#### 渲染流程（主进程、渲染进程、GPU进程）

渲染流程主要涉及将HTML、CSS和JavaScript转换为用户可以与之交互的页面，涉及了多个进程的协作：

1. **主进程：生成渲染进程**

   - 当用户打开一个新标签或输入一个URL，主进程会决定是否生成一个新的渲染进程。
2. **渲染进程的主进程：JS代码执行 & HTML、CSS的处理与渲染**

   - **构建DOM树 & CSSOM树 & 下载资源（并行）**：将 `HTML` 文件进行自上而下的解析，构建 `DOM` 树，解析 `CSS` 标记构建 `CSSOM` 树，下载CSS、JavaScript 和图片资源。
   - **执行JavaScript代码（可能与上述步骤并行）**：如果JavaScript是异步或推迟执行的，则可以与HTML解析、DOM 构建和 CSSOM 构建同步进行，否则它可能修改 DOM 和 CSSOM，导致 DOM 树和 CSSOM 树的构建暂停。同时，如果JavaScript代码中有涉及到CSS的操作，JavaScript代码会被阻塞，等 `CSSOM`构建完毕后再执行 `JS`，最后再继续 `DOM`构建。
   - **构建渲染树**：一旦有足够的 DOM 和 CSSOM 数据，浏览器就开始构建渲染树。这个过程中可能会有更多的 JavaScript 执行，对 DOM 和 CSSOM 进行修改，从而需要渲染树进行更新。渲染树排除了 `display: none`的元素，并附带样式信息。具体差别参考css文件中，display = none,visibility=hidden,opacity=0的区别这一篇。
   - **首次布局（之后就是回流）**：产生每个渲染节点（盒子）——的确切尺寸和位置。
   - **首次绘制（之后就是重绘）**：**布局后**，将渲染树的每个节点/盒子转换成实际的像素。这涉及到填充颜色、绘制边框、应用阴影、渲染文本等。这个阶段输出一系列的绘制记录。
   - **图层分割**：**绘制时或绘制后** ，主线程根据特定的规则决定页面中哪些节点应该在复合图层上处理，图层在屏幕上的相对位置和叠加关系。复合图层允许节点独立于页面其他部分进行合成。我们在下面详细说。
   - **更新绘制记录**：随着层的确定，涉及特定图层的绘制记录会更新。
   - **生成合成树**：主线程会根据图层分割生成合成树。
3. **渲染进程的合成线程** ：

   - 根据合成树的信息来**创建合成帧**。这个过程包括图像的层叠、变换和合成。这样使得部分图像处理可以在主线程之外完成，减轻了主线程的负担，并有助于提高页面渲染的性能。
4. **GPU进程合成** ：接收来自合成器的合成帧数据，通常包括纹理和绘制命令。会**执行最终的渲染操作**，生成图像。
5. **主进程：把图像呈现到屏幕** ：最后，生成的图像被发送回主进程，并由主进程提交给系统，以便于展示在屏幕上。

#### QA

js执行和渲染树构建谁先谁后？

不一定，js渲染有以下时机

* 当HTML解析器遇到一个没有 `async` 或 `defer` 属性的 `<script>` 标签时，它会立即暂停构建DOM，优先去加载和执行脚本。只有脚本执行完毕，它才会继续DOM树的构建。这可能会导致DOM构建的多次中断，特别是在脚本要求加载额外资源或者执行耗时操作的时候。
* 带有 `async` 或 `defer` 属性的脚本可能会在DOM构建完成后执行，而这可能恰好在渲染树构建过程中或之前。尤其是 `defer` 脚本，它们是在DOM构建完成后，渲染树构建前执行的。
* **事件触发的脚本** ：页面上的某些JavaScript可以注册一些事件，如 `DOMContentLoaded` 或加载（`load`）事件，这些事件可能会在构建渲染树的过程中触发JavaScript的执行。
* **脚本动态添加** ：JavaScript本身可以动态地向页面中添加更多的脚本，这些动态添加的脚本又可以修改DOM或CSSOM，进而影响渲染树的构建。
* **用户交互** ：用户与页面的交互（比如点击按钮等），可能会触发JavaScript的执行，而这个执行过程可能会影响到正在构建的渲染树。

#### 处理网络通信（主进程、网络进程）

之前在渲染进程内部处理网络通信的任务被外包给了网络进程，流程如下

1. 在渲染进程的主线程中，JavaScript代码创建XMLHttpRequest请求，主线程通过**IPC（进程间通信）把请求发送给主进程**，主进程再通过**IPC机制**将请求转发给网络进程。
2. 网络进程接收IPC消息后，**创建网络请求并处理实际的网络通信，包括与服务器的连接、数据发送和接收。**
3. 当网络进程接收到服务器响应或状态变更时，它会通过IPC发送消息回主进程，主进程再把相应通过IPC转发给渲染进程。
4. 渲染进程接收到相应后，会生成一个事件并将这个事件及其回调函数放入事件队列。
5. 渲染进程的主线程继续按照事件循环机制从事件队列中取出事件和回调进行处理和执行。

#### 用户输入（主进程、渲染进程）

1. **主进程：捕获事件 & 传递事件** ：用户的输入由主进程中的浏览器UI部分捕获，通过IPC把用户行为（事件）传送到对应的渲染进程。
2. **渲染进程主线程：事件处理** ：渲染进程的主线程接收事件，并在其事件循环中处理这些事件。
3. **更新UI** ：这些事件可能会触发视图的变更，比如布局更新、样式改变等，进入上面说的**渲染流程**

### 普通图层和复合图层

浏览器渲染的图层一般包含两大类：`普通图层`以及 `复合图层`

#### 什么是复合图层

它指的是一种可以独立于其他图层进行渲染和合成的图层，通常会被GPU单独处理，而不是在主线程上与其他图层一起处理。

#### 为什么需要复合图层

在传统的渲染流程中，所有的图层通常都是在CPU的主线程上进行布局、绘制和合成的。当页面上的一个元素改变时（如大小、颜色、位置等），这种改变有可能导致整个页面或页面的大部分重新进行布局和绘制，这会造成性能瓶颈，特别是在动画和交互频繁的情况下。

当元素属于复合图层，它会创建新的堆叠上下文，保证元素的回流和重绘能控制在最小的范围之内。当需要进行合成操作，合成线程会和gpu进程交互，把复合元素合成任务分配给gpu进程。因此，当它们变化时，浏览器只需要重绘和合成那个特定的图层，能够显著提升渲染性能。这对于改善页面滚动、动画和过渡效果的流畅度尤其有益。

#### 怎么创建复合图层

以下是一些可能会触发元素**隐式合成**为独立的复合图层的情况：

- 使用 `transform`属性的3D变换（例如 `translateZ()`，`translate3d()`）
- 对 `opacity`和 `transform`等属性的动画和过渡，由于这些能够通过合成器直接在GPU上执行，通常会创建复合图层。
- 使用CSS的 `will-change`属性
- 使用CSS固定定位或粘性定位
- 使用HTML5 Canvas元素的WebGL上下文

#### QA

**什么是堆叠上下文**

堆叠上下文是指**页面中元素渲染顺序的一个环境或者作用域**，堆叠上下文定义了**元素在这个环境内部的层次顺序，在同一个堆叠上下文的元素会放在一起渲染。**

堆叠上下文可以存在于普通图层或复合图层中，这些上下文之间的关系可以类比为嵌套的数组，其中每个数组元素（数组也可以是多维的或嵌套数组）都有其内部的顺序，但整体上彼此之间还有一个顺序。
