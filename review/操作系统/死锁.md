#### 什么是死锁

两个或两个以上并发进程，如果**每个进程持有某种资源，又等待着别的进程释放它现在保持着的资源，否则就不能向前推进**。此时，每个进程都占用了一定的资源，但又都不能向前推进。这种现象称为死锁。

#### 产生死锁的基本原因

- 竞争资源
- 进程推进顺序不当：对资源采用“申请--分配--使用--释放”模式, 由于推进顺序不当两进程都要申请对方已占有的资源。

#### 产生死锁的必要条件

- 互斥条件：一个资源每次只能给一个进程使用。

- 不可剥夺条件：资源申请者不能强行的从资源占有者手中夺取资源, 资源只能由占有者自愿释放。

- 请求和保持条件：在申请新的资源的同时保持对原有资源的占有。

- 循环等待条件：存在一个进程-等待资源环形链 `{P1,P2,…,Pn}`，其中`P1`等待`P2`占有的资源，`P2`等待`P3`占有的资源，…，`Pn`等待`P1`占有的资源。

#### 对死锁采取的对策

##### 鸵鸟策略

采用不理睬策略

##### 预防策略

破坏产生死锁的四个必要条件。

- 破坏互斥条件：使用硬软件结合改变资源特性，将“独享” 改变为“共享”。
- 破坏不可剥夺条件：进程在申请新的资源不能立即满足而变为阻塞状态之前，必须释放已占有的全部资源。
- 破坏请求和保持条件：所有进程一次性地申请在整个运行过程中全部资源，进程在整个运行期间，不再提出资源要求。
- 循环等待条件：把系统中各个资源分配特定序号，每个进程均应按照序号递增的次序请求资源，否则操作系统不予分配。

##### 避免策略

允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。

银行家算法：保证银行家状态从一个安全状态转向另一个安全状态：不死锁。

- 可用资源向量：`Available[j]= k`表示系统中第`j`类资源数为`k`个。
- 最大需求矩阵：`Max[i,j]=k`表示进程`i`对`j`类资源的最大需求数为`k`。
- 已分配矩阵：`Allocation[i,j]=k`，表示进程`i`已分得`j`类资源的数目为`k`个
- 需求矩阵：`Need[i,j]=Max[i,j]－Allocation[i,j]`，`Need[i,j]=k`表示进程`i`还需`j`类资源`k`个
- 进程`Pi`的资源申请：`Request[i]`，提出申请后，`Request[i]≤Need[i]`=>`Request[i]≤Available`
- 工作向量`Work[m]`：表示系统可提供的各类资源数目
- 标志向量`Finish[n]`：系统是否有足够资源分配给进程

##### 检测和解除

发生死锁后及时能检测出，并还能采取措施解除。

