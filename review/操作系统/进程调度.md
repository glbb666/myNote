#### 进程调度方式

##### 非抢占式调度

调度程序一旦把CPU分配给某一进程后便让它一直运行下去，直到进程完成或发生某事件而不能运行时，才将CPU分给其它进程。这种调度方式通常用在**批处理系统**中。它的主要优点是简单、系统开销小。

##### 抢占式调度

当一个进程正在执行时，系统可以基于某种策略剥夺CPU给其它进程。剥夺的原则有：**优先权原则、短进程优先原则和时间片原则**。这种调度方式多用在**分时系统和实时系统**中，以便及时响应各进程的请求。

#### 进程调度性能准则

**系统的调度性能准则**：吞吐量，处理机利用率，各种设备的均衡利用。

**用户的调度性能准则**：响应时间（分时系统），截止时间，公平性，优先级，重点掌握的是周转时间

##### 🎄周转时间 

作业从**提交到完成**所经历的时间，`Tsi`为实际运行时间

作业周转时间 = 等待时间 + 运行时间 =（过去时间 - 提交时间) + 运行时间 = 完成时间 - 提交时间

作业平均周转时间 = 各作业周转时间之和/作业个数

作业带权周转时间 = 作业周转时间/作业运行时间

作业平均带权周转时间 = 各作业带权周转时间之和/作业个数

#### 进程调度算法

##### 先来先服务（非抢占方式）

按照进程**进入就绪队列的先后次序**，分派`CPU`，当前进程占用`CPU`，直到执行完或阻塞，才出让`CPU`。在进程唤醒后（如`I/O`完成），并不立即恢复执行，通常等到当前进程让出`CPU`。

特点：有利于长作业，不利于短作业。有利于`CPU`繁忙的作业，不利于` IO`繁忙的作业。

##### 短作业优先调度算法（非抢占方式）

选择**就绪队列中**运行时间最短的进程投入运行。

特点：改善了平均周转时间和平均带权周转时间，提高系统吞吐量。不利于长作业。

##### 优先权调度算法

- 非抢占式优先级算法：仅发生在进程放弃CPU
- 抢占式优先级算法：可剥夺当前运行进程CPU

##### 高响应比优先

选择**就绪队列中**响应比最高的进程投入运行。

是先来先服务和短作业优先的折衷算法

> 响应比R = (等待时间+运行时间)/运行时间=1+等待时间/运行时间 

##### 题目：

假定在一个处理机上执行以下五个作业，
作业号  		1	2	3	4		
提交时间  	0	1	2	3	
运行时间  	8	4	9	5 
当分别采用`FCFS`、`SJF`(短作业优先)和`HRRN`（响应比高者优先）三种调度算法时，作业的调度次序以及各个作业的平均周转时间是多少？

**周转时间 = 等待时间+运行时间 = (过去时间-提交时间)+运行时间**

**过去时间 = CPU运行+CPU空闲的时间**

先来先服务：它的调度顺序为1，2，3，4

| 货物号           | 货物周转时间                            | 过去时间 |
| ---------------- | --------------------------------------- | -------- |
| 1                | (0-0)+8 = 8                             | 8        |
| 2                | (8-1)+4 = 11                            | 12       |
| 3                | (12-2)+9 = 19                           | 21       |
| 4                | (21-3)+5 = 23                           | 26       |
| 平均周转时间     | (8+11+19+23)/4 = 61/4 = 15.25           |          |
| 平均带权周转时间 | (8/8+11/4+19/9+23/5)/4 = 10.46/4 = 2.61 |          |

短作业优先：它的调度顺序为1,2,4,3

| 货物号           | 货物周转时间                            | 过去时间 |
| ---------------- | --------------------------------------- | -------- |
| 1                | (0-0)+8 = 8                             | 8        |
| 2                | (8-1)+4 = 11                            | 12       |
| 4                | (12-3)+5 = 14                           | 17       |
| 3                | (17-2)+9 = 24                           | 26       |
| 平均周转时间     | (8+11+14+24)/4 = 57/4 = 14.25           |          |
| 平均带权周转时间 | (8/8+11/4+14/5+24/9)/4 = 10.46/4 = 2.30 |          |

高响应比优先：它的调度顺序为1，2，4，3

| 货物号           | 货物周转时间                            | 过去时间 |
| ---------------- | --------------------------------------- | -------- |
| 1                | (0-0)+8 = 8                             | 8        |
| 2                | (8-1)+4 = 11                            | 12       |
| 4                | (12-3)+5 = 14                           | 17       |
| 3                | (17-2)+9 = 24                           | 26       |
| 平均周转时间     | (8+11+14+24)/4 = 57/4 = 14.25           |          |
| 平均带权周转时间 | (8/8+11/4+14/5+24/9)/4 = 10.46/4 = 2.30 |          |

##### 时间片轮转调度算法

通过时间片轮转，提高进程**并发性**和**响应时间**特性，从而提高**资源利用率**。

将系统中所有的就绪进程按照`FCFS`原则，排成一个队列。 每次调度时将`CPU`分派给队首进程，让其执行一个时间片，结束时，发生时钟中断。调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过`CPU`现场切换执行当前的队首进程。进程可以未使用完一个时间片，就出让`CPU`（如阻塞）。 

##### 多级反馈队列算法

设置多个不同优先级的就绪队列，队列1的优先级最高，其他逐级降低。优先级越高分配的时间片越短。
新进程就绪后，先投入队列1的末尾，按`FCFS`算法调度。若一个时间片未能执行完，则降低投入到队列2的末尾；依此类推，降低到最后的队列，则按“时间片轮转”算法调度直到完成。
进程由于等待事件而放弃`CPU`后，进入等待队列， 一旦等待的事件发生，则回到原就绪队列。
仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列末尾。