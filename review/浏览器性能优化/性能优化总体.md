# 性能优化

- 用户体验
  - `loading`可以大大缓解等待时候的无聊和焦虑，有效让用户明确知道目前`Loading`的状态，并对结果有一个直观的预期
- 网络方面
  - 减少`HTTP`请求个数（缓存等）
  - 图片优化
    - 雪碧图
    - `base64`编码替代图片，减少图片的网络请求
    - 图片压缩
    - 图片懒加载
    - 图片预加载
    - 采用正确的图片格式
      - 尽量使用 `WebP` 格式。因为 `WebP` 格式具有更好的图像数据压缩算法，能在图像质量相同的下带来更小的图片体积，缺点就是兼容性并不好
      - 色彩很多的使用 `JPEG`
      - 色彩种类少的使用 `PNG`，有的可用`SVG`代替
  - `CDN`
- 页面渲染（减少回流和重绘）
  - 不用`js`操作样式，而是切换class
  - 元素离线更新（`document.fragment`对元素进行一次性的操作，再添加到页面中）
- `js`阻塞方面
  - `defer`和`async`防止`js`对`dom`解析的阻塞
  - 首屏的`js`放底部

### `Base64`编码原理

`Base64`编码是基于64个字符`A-Z,a-z，0-9，+，/`的编码方式，因为`2^6=64`，所以就用`6bit`就可以表示出`64`个字符，000000对应A，000001对应B。

**`Base64`编码本质**上是一种将二进制数据转成文本数据的方案。以每 3 个 字符为一组，然后针对每组，首先获取每个字符的` ASCII` 编码(字符'a'=97=01100001)，然后将` ASCII `编码转换成` 8 bit` 的二进制，得到一组 `3 * 8=24 bit `的字节。然后再将这 `24 bit `划分为 `4` 个 `6 bit` 的字节，并在每个 `6 bit` 的字节前面都填两个高位 0，得到 4 个 8 bit 的字节，然后将这 4 个 8 bit 的字节转换成十进制，对照 `BASE64 `编码表 （下表），得到对应编码后的字符。

### 图片懒加载原理

为了加速页面加载速度，页面可视区域外的图片先不做加载， 等到滚动到可视区域内后再去加载。

将页面中的img标签src指向一张小图片或者src为空，然后定义`data-src`（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。`src`指向一张默认的图片，否则当`src`为空时也会向服务器发送一次请求。可以指向`loading`的地址。

```html
<img src="default.jpg" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" />
```

我们可以监听页面的滚动事件，当图片距离顶部的偏移(`offsetTop`)小于滚动条卷曲的高度(`scrollTop`)和页面原始高度(`clientHeight`)之和的时候，说明图片进入了页面的可视区域内，就把图片的`src`替换为`data-src`的内容。

### 插入几万个 DOM，如何实现页面不卡顿？

肯定不能一次性把几万个 `DOM` 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 `DOM`。

- `requestAnimationFrame` 的方式去**循环插入** DOM
- **虚拟滚动**（`virtualized scroller`）。

这种技术的原理就是**只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

[![滚动](https://github.com/zyg1999/Note/raw/master/review/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic/vScroll.png)](https://github.com/zyg1999/Note/blob/master/review/性能优化/pic/vScroll.png)

从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这发问题。如果你想了解更多的内容可以了解下这个 [react-virtualized](https://github.com/bvaughn/react-virtualized)。