# 性能优化

- 用户体验
  - `loading`可以大大缓解等待时候的无聊和焦虑，有效让用户明确知道目前`Loading`的状态，并对结果有一个直观的预期
- 网络方面
  - 配置缓存，减少`http`请求，利用`md5 hash`后缀对缓存进行更新
  - 代码压缩
  - `DNS`预解析：
    - 在`html`下载完成之后，提前把其中包含的链接解析成`ip`地址
    - 对于访问过的页面，浏览器会记录域名列表，在第二次打开的时候，会边下载`html`边将其中的链接解析成`ip`地址
  - 图片优化
    - 不用图片，一些修饰性图片可以用`css`代替
    - 使用雪碧图，将多个图标文件整合到一张图中
    - `base64`编码替代图片，减少图片的网络请求
    - 图片压缩
    - 图片懒加载
    - 图片预加载
    - 采用正确的图片格式
      - 尽量使用 `WebP` 格式。因为 `WebP` 格式具有更好的图像数据压缩算法，能在图像质量相同的下带来更小的图片体积，缺点就是兼容性并不好
      - 色彩很多的使用 `JPEG`
      - 色彩种类少的使用 `PNG`，有的可用`SVG`代替
  - `CDN`：内容分发网络，指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，用户每次获取的是最近的服务器的数据，从而实现加速。
- 页面渲染（减少回流和重绘）
  - 不用`js`操作样式，而是切换class
  - 元素离线更新（`document.fragment`对元素进行一次性的操作，再添加到页面中）
- `js`方面
  - `defer`和`async`防止`js`对`dom`解析的阻塞
  - 首屏的`js`放底部
  - `SSR`：执行`js`获得`DOM`的过程由浏览器放到了服务器
  - 减少闭包的使用，因为闭包对内存和资源都会有所消耗

### `Base64`编码原理

`Base64`编码是基于64个字符`A-Z,a-z，0-9，+，/`的编码方式，因为`2^6=64`，所以就用`6bit`就可以表示出`64`个字符，000000对应A，000001对应B。

**`Base64`编码本质**上是一种将二进制数据转成文本数据的方案。以每 3 个 字符为一组，然后针对每组，首先获取每个字符的` ASCII` 编码(字符'a'=97=01100001)，然后将` ASCII `编码转换成` 8 bit` 的二进制，得到一组 `3 * 8=24 bit `的字节。然后再将这 `24 bit `划分为 `4` 个 `6 bit` 的字节，并在每个 `6 bit` 的字节前面都填两个高位 0，得到 4 个 8 bit 的字节，然后将这 4 个 8 bit 的字节转换成十进制，对照 `BASE64 `编码表 （下表），得到对应编码后的字符。

### 图片懒加载原理

为了加速页面加载速度，只加载可视区域的图片内容。

将页面中的`img`标签`src`指向一张小图片或者`src`为空，然后定义`data-src`（这个属性可以自定义命名，我才用`data-src`）属性指向真实的图片。`src`指向一张默认的图片，否则当`src`为空时也会向服务器发送一次请求。

```html
<img src="default.jpg" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" />
```

我们可以监听页面的滚动事件，当图片距离顶部的偏移(`offsetTop`)小于滚动条卷曲的高度(`scrollTop`)和页面原始高度(`clientHeight`)之和的时候，说明图片进入了页面的可视区域内，就把图片的`src`替换为`data-src`的内容。

### `DNS`预解析

现代浏览器在` DNS Prefetch `上做了两项工作：

1. `html `源码下载完成后，会解析页面的包含链接的标签，提前查询对应的域名
2. 对于访问过的页面，浏览器会记录一份域名列表，当再次打开时，会在 `html` 下载的同时去解析 `DNS`

**自动解析**

浏览器使用超链接的`href`属性来查找要预解析的主机名。当遇到`a`标签，浏览器会自动将`href`中的域名解析为`IP`地址，这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在`HTTPS`页面中不会自动解析

**手动解析**

```
预解析某域名
<link rel="dns-prefetch" href="//img.alicdn.com">
强制开启HTTPS下的DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on">
```

### 插入几万个 DOM，如何实现页面不卡顿？

肯定不能一次性把几万个 `DOM` 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 `DOM`。

- `requestAnimationFrame` 的方式去**循环插入**` DOM`
- **虚拟滚动**（`virtualized scroller`）。

这种技术的原理就是**只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

[![滚动](https://github.com/zyg1999/Note/raw/master/review/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic/vScroll.png)](https://github.com/zyg1999/Note/blob/master/review/性能优化/pic/vScroll.png)

从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这发问题。如果你想了解更多的内容可以了解下这个 [react-virtualized](https://github.com/bvaughn/react-virtualized)。