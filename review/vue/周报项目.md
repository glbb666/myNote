## 路由

## `cookie`和`session`如何实现登陆注册

- 前端登陆
- 后台验证成功后把前端的状态信息，比如存在`session`里，并把`session_id`设置前端的`cookie`里
- 只要这个`cookie`没有被清除或过期，前端每一次请求都会带上这个`cookie`，后台会根据这个`session_id`找出相应的用户
- 我们可以在`session`里设置时间戳，每一次前端发起请求都会对这个时间戳进行更新，这样我们就可以设置超时掉线了。

## `token`呢

用户把用户名和密码发给后端，后端验证后用一系列算法加密后发给前端，前端设置把它设置在`localStorage`中，在之后的每一次请求中都要带上`token`，服务器收到`token`进行解密和签名认证，判断其有效性。

## `canvas`图片压缩过程

- 类型为`file`的`input`标签上传文件
- 用`FileReader`的`readAsDataURL`读取图片，获取到的是一个`base64`的`url`
- 创造一个图片对象`oImg`
- 用`FileReader`的`load`回调中，把`oImg`的`src`设置为这个`url`
- 用`context.drawImage(image, x, y, width, height)`将图片进行压缩

问题：如果canvas绘制图片模糊怎么办？

canvas适配高倍屏，将canvas放大到设备像素比来绘制，最后将canvas压缩成一倍的物理大小来显示。

要设置canvas的画布大小，使用的是canvas.width 和 canvas.height；
要设置画布的实际渲染大小，使用的style或CSS设置的 width 和height，只是简单的对画布进行缩放。

```javascript
canvas.style.width = canvas.width;
canvas.style.height = canvas.height;

canvas.width = canvas.width * ratio;
canvas.height = canvas.height * ratio;
```

- `canvas.toDataURL(callback, mimeType, qualityArgument) `将图片导出，这里可以指定图片的质量
- `canvas.toBlob`把文件转换为`Blob`格式上传

 ## 如何使用中间件

- `npm`下载
- `require`引入
- 