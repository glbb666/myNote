### 0.1+0.2===0.3吗，为什么？

不等于，因为` JS` 遵循 IEEE 754 标准双精度版本， 通过64位来表示一个数字。其中1位符号位，指数部分占11位，尾数部分占52位。

![img](images/165e0eb7f4d6c50f)

运算时，会把数字**先按照IEEE 754转成相应的二进制**，然后**对阶运算**，这两个过程中**都会产生精度损失**。

 `0.1` 和 `0.2` 转换为二进制后都是无限循环的，而IEEE 754尾数位数是有限的，所以需要把位数进行截断，在它们进行加法运算时，如果指数位不同，还需要进行对阶运算，这也会产生精度损失。

#### 解决办法

- 第三方库，比如`Math.js`

```javascript
parseFloat((0.1 + 0.2).toFixed(10))//tOFixed方法，保留小数点后n位
```

### Number()的存储空间是多大

Number的存储空间为2的53次方

> 为什么多了一位？
>
> 二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。因此，JavaScript提供的有效数字最长为53个**二进制位**

```javascript
Number.MIN_SAFE_INTEGER==-Math.pow(2,53)+1//true
Number.MAX_SAFE_INTEGER==Math.pow(2,53)-1//true
```

### 如果后台发送了一个超过最大字节的数字怎么办

- 后台把number转化为string传给前端
- 前端用buffer来流式获取