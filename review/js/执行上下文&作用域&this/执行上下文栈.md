# 执行上下文栈

当**执行一个函数的时候，就会创建一个执行上下文。**

"执行上下文"是执行函数时的“**准备工作**”。

**并且压入执行上下文栈**，当**函数执行完毕的时候，就会将函数的执行上下文从栈中弹出**。

对于全局而言：初始化的时候首先会向执行上下文栈底部压入一个全局执行上下文，并且只有当整个应用程序结束的时候，全局执行上下文才会弹出。

# 执行上下文

当 `JavaScript` 代码执行一段可执行代码时，会创建对应的执行上下文

对于**每个执行上下文**，都有三个重要属性：

- 变量对象
- 作用域链
- `this`

![1601649843378](images/1601649843378.png)

## 变量对象

变量对象是与执行上下文相关的数据作用域，**存储了在上下文中定义的变量和函数声明**。

它包含以下部分

1. **形参**
   - 形参会被添加到变量对象中，并赋值为调用时传入的参数值。
2. **函数声明**
3. **变量声明**
   - 函数体内的所有变量声明也会添加到变量对象中，初始化为 `undefined`。

如果形参和变量声明同名。会有以下情况发生

- 形参和 `var`声明的变量共享同一个存储位置
- 形参初始化优先于 `var`声明的提升，因此变量会先被赋上实参的值
- 但如果存在同名的形参，该变量不会被重新初始化为 `undefined`，而是保持形参的值。
- 在代码执行过程中，如果同名的变量被重新赋值，这个共享的存储位置的值就会被更新。

```js
function example(param) {
    console.log(param); // 输出 1
    var param = 2;
    console.log(param); // 输出 2
}

example(1);

```

### 全局对象:

全局上下文下的**变量对象为全局对象**

1.客户端 `JavaScript` 中，全局对象就是 `Window` 对象。

2.全局对象是由 `Object` 构造函数实例化的一个**对象**。

3.**预定义**了许多函数和属性。如 `Math.random()`

4.作为**全局变量的宿主**。

### 活动对象

活动对象是**被激活的变量对象**，这个变量对象在进入函数执行上下文时刻被激活，它通过函数的 `arguments` 属性初始化。变量对象在被激活前不可访问。

### 作用域

通过上述概念，你有没有觉得活动对象似乎就是作用域？

是的，**作用域本就是个抽象的概念，在实际运行时，这个抽象的作用域概念被具体化为变量对象**。

这是因为

## 作用域链

那作用域链是什么呢？从名字上看，它和作用域似乎有关系。

**作用域链是由多个执行上下文的变量对象构成的链表**。

**当函数创建时**，会在函数对象上创建一个名为 `[[scope]]`的内部属性。它的值是**所有父变量对象的层级链**。

**当函数执行时**，基于函数创建时保存的 `[[scope]]`，会创建一个新的执行上下文。在这个执行上下文中，会将当前函数的活动对象添加到 `[[scope]]`链的顶端。**这就是作用域链**。

这种特性也决定了作用域链是静态的。

### 举个例子

```js
let fn = function() {
    let fn1 = function() {
        console.log(b);
    }
    fn1();
}

let fan = (fn) => {
    let b = 2;
    fn();
}

fan(fn);

```

就拿这段函数举例。

fn的[[scope]]是[全局对象]。就算fn在fan中执行，fn1是在fn中定义（fn不存在变量提升，执行到那一行代码定义），所以fn1的[[scope]]为[[全局对象，fn的AO]]。

因此fn1中是拿不到b的值的。

## this

this因为比较复杂，请看执行上下文&作用域&this/深入this

## 捋一捋执行上下文栈、作用域和变量对象

以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：

```js
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope()
```

执行过程如下：

1. `checkscope` 函数被创建，保存作用域链到内部属性[[scope]]（所有父变量对象的层级链）

```js
checkscope.[[scope]] = [
    globalContext.VO
]
```

2. **执行 `checkscope` 函数，创建 `checkscope` 函数执行上下文**，`checkscope` 函数执行上下文被压入执行上下文栈

```js
ECStack = [
    checkscopeContext,
    globalContext
]
```

3. `checkscope` 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性到**checkscope 函数执行上下文**创建作用域链

```js
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
```

4. 用 `arguments` 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }
}
```

5. 将活动对象压入 `checkscope` 作用域链顶端

```
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```

6. 准备工作做完，开始执行函数，随着函数的执行，修改 `AO` 的属性值

```
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```

7. 查找到 `scope2` 的值，**返回后函数执行完毕，函数上下文从执行上下文栈中弹出**

```
ECStack = [
    globalContext
];
```

## 总结

js的执行上下文和作用域是很容易被混淆的概念。

js的执行上下文是动态的，和this指向有关。

js的作用域是静态的，和变量有关。

记住这两点，能解决很多问题。
