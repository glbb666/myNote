## 什么是垃圾回收机制

**执行环境**会负责**管理**代码执行过程中使用的**内存**。

GC做什么了：

- 找到内存空间中的垃圾。
- 回收垃圾，让程序员能再次利用这部分空间。

## `V8`引擎分代回收

分代回收会区分「新生代」与「老生代」对象。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。多回收「新生代对象区」，少回收「老生代对象区」

对象起初都会被分配到新生代，当新生代中的对象满足某些条件时，会被移动到老生代（晋升）。

![img](images/1666705188841473)

### 新生代到老生代转化条件

- 新生代中的对象是否已经经历过一次复活算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- **To 空间的对象占比大小超过 25 %。** 在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

### 新生代算法

#### 复制算法

- 复制算法将内存空间分为大小相等的两块，分别为使用的 From 空间和闲置的 To 空间。
- 新分配的对象会被放入 From 空间中，当 From 空间被占满时，启动 `GC`，**把 From 空间中存活的对象复制到 To 空间中，销毁失活的对象**。
- 当复制完成后将 `From` 空间和 `To` 空间互换，这样 `GC` 结束

**优点**

- 每次都是对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可

**缺点**

- 只能使用堆内存的一半，但是由于它只复制存活的对象，对于生命周期短的场景来说，存活对象只占少部分，所以在时间效率上有优异的表现。

### 老生代算法

#### 标记清除算法

在老生代中的对象，由于存活对象占比大，所以如果用复制算法就会有复制效率低的问题。

`V8`的老生代算法为标记清除法和标记整理算法。

垃圾回收器在运行的时候会（1）深度遍历内存中的所有对象，并标记活着的对象。（2）清除没有被标记的对象。

**优点**

- 老生代中死对象占比少，因此算法可以高效处理。
- 解决了循环引用的问题。

**缺点**

- 造成碎片化，如果没有找到合适大小的内存块，就会提前触发不必要的垃圾回收，所以在此基础上提出标记整理算法

#### 标记整理算法

标记整理算法会在标记完存活对象之后，将存活对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。

## 引用计数

顾名思义：**跟踪记录每个值被引用的次数**。

垃圾回收器运行时，会释放那些应用次数为0的值所占的内存。

```
var a = new Object(); // 此时'这个对象'的引用计数为1（a在引用）
var b = a; // ‘这个对象’的引用计数是2（a,b）
a = null; // reference_count = 1
b = null; // reference_count = 0 
// 下一步 GC来回收‘这个对象’了
```

**优势**

- **可即时回收**，当被引用值为0时，对象马上会把自己作为空闲内存链接到空闲链表上。
- **最大暂停时间短**，因为 `GC`时 `JS`会停止运行，立即回收的话 `GC`时间短。
- 不用去遍历堆里面的所有活动对象和非活动对象

**缺点**

- 计数器占位大
- 无法解决循环引用问题

**循环引用：**对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针。循环引用会造成**内存泄漏**

**内存泄漏**：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

如何避免循环应用呢？在不使用他们的时候手工断开连接，把被循环应用的值设为null。

### 参考文章

[JS垃圾回收机制笔记](https://juejin.im/post/6844903695721709581#heading-17)
