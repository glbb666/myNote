### 什么是“组合（Composition）”？

* **定义** ：组合是一种通过将多个独立的功能模块（对象、函数、组件等）组合在一起，来创建更复杂的功能模块的方式。这种方式强调通过组合不同的功能单元来实现复用，而不是通过继承层次来共享功能。
* **核心思想** ：把功能分解成多个独立的模块（函数、对象、组件等），然后通过组合这些模块来构建更复杂的系统。
* **示例** ：想象一辆车，它可以组合不同的部件（如引擎、轮子、方向盘）来构成整体，而不是从某个“基础车型”继承来实现不同功能。

```js
// 定义独立的功能模块
function canEat() {
  return {
    eat() {
      console.log('I can eat');
    }
  };
}

function canWalk() {
  return {
    walk() {
      console.log('I can walk');
    }
  };
}

function canSwim() {
  return {
    swim() {
      console.log('I can swim');
    }
  };
}

// 使用组合来创建更复杂的对象
function Person() {
  return Object.assign({}, canEat(), canWalk());
}

function Fish() {
  return Object.assign({}, canEat(), canSwim());
}

const person = Person();
person.eat(); // 输出: I can eat
person.walk(); // 输出: I can walk

const fish = Fish();
fish.eat(); // 输出: I can eat
fish.swim(); // 输出: I can swim

```

### 什么是“继承（Inheritance）”？

* **定义** ：继承是一种通过创建基类（父类）并从中派生子类的方式来实现代码复用的方法。子类继承了父类的属性和方法，可以在子类中进一步扩展或重写父类的功能。
* **核心思想** ：通过层次化的类结构，将通用功能封装在父类中，然后通过子类继承和扩展父类来实现具体的功能。
* **示例** ：想象一棵家谱树，父类代表祖先的通用特征，而子类代表更具体的个体，并可以增加或修改特征。

```js
class Animal {
  eat() {
    console.log('I can eat');
  }
}

class Dog extends Animal {
  bark() {
    console.log('I can bark');
  }
}

const dog = new Dog();
dog.eat(); // 输出: I can eat
dog.bark(); // 输出: I can bark

```

### 组合与继承的区别

| 特点               | **组合（Composition）** | **继承（Inheritance）**            |
| ------------------ | ----------------------------- | ---------------------------------------- |
| **耦合度**   | 低：组件之间相对独立          | 高：子类与父类耦合紧密                   |
| **灵活性**   | 高：可以灵活组合模块          | 低：继承层次越深，灵活性越差             |
| **代码复用** | 通过模块化组合                | 通过类层次结构                           |
| **修改扩展** | 更容易增加新功能              | 修改父类可能影响所有子类                 |
| **使用场景** | 适合解决功能复用、灵活扩展    | 适合实现 “is-a” 关系（如“猫是动物”） |

### 为什么更推荐使用“组合”而非“继承”？

* **减少耦合** ：组合通过组合模块来构建功能，而不是依赖复杂的继承链，减少了模块之间的耦合。
* **更灵活** ：你可以选择组合不同的模块来实现特定的功能，而不必受限于继承层次，可以更灵活地应对变化。
* **避免继承的“脆弱基类问题”** ：当基类发生变化时，所有子类都可能受到影响，而组合更容易调整和扩展，不会影响其他模块。
