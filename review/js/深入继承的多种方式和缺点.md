## 1.原型链继承

做法：父类实例作为子类原型，方法写在父类原型上

缺点：子类实例共享引用类型，子类不可向父类传参

```javascript
function Parent () {
    this.name = 'kevin';
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

console.log(child1.getName()) // kevin
```

缺点：

1.**引用类型的属性**被所有实例共享，举个例子：

```javascript
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]
```

2.在创建 Child 的实例时，不能向Parent传参

## 2.借用构造函数(经典继承)

做法：子类调用父类

优点：原型链模式的缺点（1、引用类型不被实例共享2、子类可向父类传参）

缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法。

```javascript
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {
    Parent.call(this);
}

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]
```

举个例子：

```javascript
function Parent (name) {
    this.name = name;
}

function Child (name) {
    Parent.call(this, name);
}

var child1 = new Child('kevin');

console.log(child1.name); // kevin

var child2 = new Child('daisy');

console.log(child2.name); // daisy
```



## 3.组合继承

原型链继承和经典继承双剑合璧。

做法：1.父类实例作为子类原型，方法写在父类原型上2.子类调用父类

优点：融合原型链继承和构造函数的优点，是 JavaScript 中**最常用的继承模式**。

缺点：父类调用两边，子类原型有冗余属性

```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```



## 4.原型式继承

作用：基于原有的对象创造新对象

```javascript
function createObj(o) {
    function F(){}
    F.prototype = o;
    return new F();
}
```

就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

缺点：

包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

```javascript
var person = {
    name: 'kevin',
    friends: ['daisy', 'kelly']
}

var person1 = createObj(person);
var person2 = createObj(person);

person1.name = 'person1';
console.log(person2.name); // kevin

person1.firends.push('taylor');
console.log(person2.friends); // ["daisy", "kelly", "taylor"]
```

注意：修改`person1.name`的值，`person2.name`的值并未发生改变，并不是因为`person1`和`person2`有独立的 name 值，而是因为`person1.name = 'person1'`，给`person1`添加了 name 值，并非修改了原型上的 name 值。

## 5. 寄生式继承

作用：增强对象

做法：1.基于原有的对象创造新对象2.给新对象添加方法

```javascript
function createObj (o) {
    var clone = Object.create(o);
    clone.sayName = function () {
        console.log('hi');
    }
    return clone;
}
```

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

## 6. 寄生组合式继承

寄生组合继承=原型式继承+组合式继承

目的：为了解决组合继承中父类被调用两次(1.在子类中调用父类2.把父类实例作为子类原型)

想法：其实我们想要的只是父类的原型上的方法

做法：用寄生式继承对组合继承进行优化(创建父类和子类的中间层)

为了方便大家阅读，在这里重复一下组合继承的代码：

```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

Child.prototype = new Parent();

var child1 = new Child('kevin', '18');

console.log(child1)
```

组合继承最大的缺点是会调用两次父构造函数。

第一次是设置子类型实例的原型的时候：

```javascript
Child.prototype = new Parent();
```

第二次在创建子类型实例的时候：

```javascript
var child1 = new Child('kevin', '18');
```

回想下 new 的模拟实现，其实第一次中，我们会执行：

```javascript
Parent.call(this, name);
```

所以，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为`colors`，属性值为`['red', 'blue', 'green']`。

为了避免这一次重复调用，我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype

看看如何实现：

```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

// 关键的三步
var F = function () {};

F.prototype = Parent.prototype;

Child.prototype = new F();


var child1 = new Child('kevin', '18');

console.log(child1);
```

最后我们封装一下这个继承方法：

```javascript
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

function prototype(child, parent) {
    var prototype = object(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}

// 当我们使用的时候：
prototype(Child, Parent);
```

寄生组合式继承只调用了一次 Parent 构造函数，并且因此**避免了在 Parent.prototype 上面创建多余的属性**。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。

## 7. Class的继承
### 简介
做法：Class 可以通过`extends`关键字实现继承

```javascript
class Point {
}
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

**子类必须在`constructor`方法中调用`super`方法(父类的构造函数)**，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象。

```
子类this = 父类塑造+子类塑造
```

如果子类没有定义`constructor`方法，这个方法会被**默认添加**

```javascript
class ColorPoint extends Point {
}

// 等同于
class ColorPoint extends Point {
  constructor(...args) {
    super(...args);
  }
}
```

**在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字**，否则会报错。这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。

**子类会继承父类的静态方法**

```javascript
class A {
  static hello() {
    console.log('hello world');
  }
}

class B extends A {
}

B.hello()  // hello world
```

### Object.getPrototypeOf()

`Object.getPrototypeOf`方法可以用来从子类上获取父类

```javascript
Object.getPrototypeOf(ColorPoint) === Point
// true
```

因此，可以使用这个方法判断，一个类是否继承了另一个类

### super 关键字

`super`这个关键字，既可以当作函数使用，也可以当作对象使用。

#### 当作函数使用

1. `super`作为函数调用时，代表**父类的构造函数**，ES6 要求，子类的构造函数必须执行一次`super`函数

```javascript
class A {}
class B extends A {
  constructor() {
    super();
  }
}
```

2. 注意，<font color='red'>`super`虽然代表了父类`A`的构造函数，但是返回的是子类`B`的实例，即`super`内部的`this`指的是`B`的实例</font>，因此`super()`在这里相当于`A.prototype.constructor.call(this)`。

```javascript
class A {
  constructor() {
    console.log(new.target.name);
  }
}
class B extends A {
  constructor() {
    super();
  }
}
new A() // A
new B() // B
```

上面代码中，`new.target`指向当前正在执行的函数。可以看到，在`super()`执行时，它指向的是子类`B`的构造函数，而不是父类`A`的构造函数。也就是说，`super()`内部的`this`指向的是`B``

3. `super()`**只能用在子类的构造函数**之中

#### 当作对象使用

1. 在**普通方法（包括constructor）**中，指向**父类的原型对象**；在**静态方法**中，指向**父类**。

   💥注意，由于`super`指向父类的原型对象，所以<font color='red'>定义在父类实例上的方法或属性，是无法通过`super`调用的</font>

   ```javascript
   class A {
     constructor() {
       this.p = 2;
     }
   }
   A.prototype.x = 2;
   class B extends A {
     getValue () {
       console.log(super.p,super.x)
     }
   }
   
   let b = new B();
   b.getValue() // undefined 2
   ```

   上面代码中，`p`是父类`A`实例的属性，x是父类`A`原型的属性，可以看出super只能引用原型上的属性
   
2. 在普通方法中通过`super`调用父类的方法时，**<font color='red'>父类方法内部</font>的`this`指向当前的子类实例**

   💥注意：由于`this`指向子类实例，所以<font color='red'>如果通过`super`对某个属性赋值</font>，这时`super`就是`this`，<font color='red'>赋值的属性会变成子类实例的属性</font>

```javascript
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```