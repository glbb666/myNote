

# 数组方法（4转换+2栈+2队列+2重排序+2操作+2位置+5迭代+2归并=22种）

## 转换方法（不会改变数组）

### valueOf()

返回**数组本身**

### toString()

**调用**数组中**每一项的toString()方法**，返回由他们返回的字符串值拼接而成的一个**以逗号分隔的字符串**

### toLocaleString()

**调用**数组中**每一项的toLocaleString()方法**，返回由他们返回的字符串值拼接而成的一个**以逗号分隔的字符串**

### join()

如果调用join方法，可以**使用不同的分隔符**来构建这个字符串。join也是调用**数组中**每一项的toString()方法。join方法只接受一个参数，即**用作分隔符的字符串**。如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符。

> 如果数组中的某一项是null或者undefined，那么该值在join()，toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示

## 栈方法（会改变数组）

### push()

作用：接受**任意数量**的参数，把它们**逐个添加**到函数**末尾**

返回：修改后数组的长度

### pop()

作用：从数组末尾移除最后一项，减少数组的length值

返回：移除的项

## 队列方法（会改变数组）

### shift()

作用：从数组中移除第一项，并且将数组方法减一

返回：移除的项

### unshift()

作用：在数组前端添加任意个项

返回：新数组的长度

> 区分shift和unshift==>长的是添加的

## 重排序方法(会改变数组)

### reverse()

作用：反转数据项的顺序

返回：经过排序后的数组

```js
var a = [1,2,3,4,5];
var b = a.reverse();
console.log(a);//[5,4,3,2,1]
console.log(b);//[5,4,3,2,1]
```

因为reverse()方法不够灵活，所以有了sort方法

### sort()

作用：按**升序**排列数组项，sort会调用每个数组项的toString()方法，然后`比较得到的字符串`，以确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也都是字符串

返回：经过排序后的数组

```js
var value = [0,1,5,10,15];
value.sort();
console.log(value);//[0,1,10,15,5]
```

由上，字符串比较有缺陷。sort方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。

比较函数（升序）将第一个参数和第二个参数用**关系型操作符**进行比较，这涉及到[数据类型转换](https://github.com/glbb666/myNote/blob/master/review/js/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.md)，第一个参数在第二个参数前面返回-1，相等0，后面1。

```js
function compare(value1,value2){
	if(value1<value2){
		return -1;
	}else if(value1>value2){
		return 1;
	}else{
		return 0;
	}
}
```

对于数值类型或者valueOf方法会返回数值类型的对象类型，可以使用一个更简单的比较函数

```js
function compare(value1,value2){
	return value1-value2;
}
```

## 操作方法

### concat()(不改变数组)

作用：**基于当前数组**中的所有项**创建**一个**新数组**。

（1）先创建给当前数组一个副本

（2）将接收到的一到多个参数添加到这个数组的末尾（数组则添加每一项，非数组则简单添加至末尾）

（3）**返回**新构建的数组。

```js
var colors = ['red','green','blue'];
var colors2 = colors.concat();//没有传入参数，复制数组并返回副本
alert(colors)//red,green,blue
alert(colors2)//red,green,blue

var colors = ['red','green','blue'];
var colors3 = colors.concat('yellow',['black','brown']);
alert(colors)//red,green,blue
alert(colors3)//red,green,blue,yellow,black,brown
```

### slice()(不改变数组)

作用：基于当前数组中的一或多个项创建一个新数组。

（1）接受两个参数，要返回项的起始位置和结束位置。

（2）一个参数，返回从该参数指定位置开始到当前数组末尾的所有项。

（3）两个参数，返回起始位置和结束位置之间的项（不包括结束位置的项）。

```js
var colors = ['red','green','blue','black','brown'];
colors.slice()
//(5) ["red", "green", "blue", "black", "brown"]
colors.slice(0,2)
//(2) ["red", "green"]
colors.slice(0)
//(5) ["red", "green", "blue", "black", "brown"]
```

> 如果slice()方法的参数中有一个负数，则用**数组长度加上该数来确定相应的位置。**例如，在一个包含5项的数组上调用slice(-2,-1)可以认为slice(-2+5,-1+5)，即和调用slice(3,4)的结果相同。如果结束位置小于起始位置，则返回空数组。

### splice()(<font color="red">改变原数组</font>)

作用：删除，插入，替换。

（1）接受三个参数：起始位置，要删除的项数，要插入的项（可以为多项）

（2）删除：前两个参数

（3）插入：第二个参数设为0，第三个是要插入的项

（4）替换：第二个参数设为要被替换掉的项，第三个是用来替换的项。

返回值：返回一个包含从原始数组中删除的项的数组。（没有删除返回空数组）

```js
var colors = ['red','green','blue']

//删除一项
colors.splice(0,1)
//["red"]
console.log(colors)
//(2) ["green", "blue"]

//从开头插入两项
colors.splice(0,0,'pink','black')
//[]
colors
//(4) ["pink", "black", "green", "blue"]

//用两项替换一项
colors.splice(1,1,'yellow','yellow2')
//["black"]
colors
//(5) ["pink", "yellow", "yellow2", "green", "blue"]
```

## 位置方法（不改变数组）

### indexOf()

作用：**从左到右**查找数组中的某一项。

（1）接受两个参数：要查找的项，表示查找起点的索引（会对查找起点进行查找，默认值为0）。

### lastIndexOf()

作用：**从右到左**查找数组中的某一项。

（1）接受两个参数：要查找的项，表示查找起点的索引（会对查找起点进行查找，默认值为最后一项的索引）。

**它们的返回值**：要查找的项在数组中的**索引**，没找到返回-1，查找的项必须严格相等（**===**）

```js
var a = 'sdfadfsdsad'
a.lastIndexOf('a')
//9
a.lastIndexOf('a',3)
//3
```

## 迭代方法（不改变数组）

接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象（this）。

传入这些放的的函数会接受三个参数：数组项的值，项的索引，数组对象

#### 有返回值

##### 返回值为布尔值

### every()

作用：如果或该函数对每一项都返回true，则返回true

### some()

作用：如果该函数对任一项返回true，则返回true

##### 返回值为数组

### filter()

作用：返回该函数会返回true的项组成的数组

### map()

作用：返回每次函数调用的结果组成的数组

#### 无返回值

### forEach()

作用：这个方法没有返回值

## 归并方法（不改变数组）

接受两个参数，在每一项上调用的函数和作为归并基础的初始值。

函数接受四个参数：前一个值、当前值、项的索引、数组对象

作用：迭代数组的所有项，构建一个最终返回的值

### reduce()

作用：从头到尾遍历数组

### reduceRight()

作用：从尾到头遍历数组

```js
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev,cur,index,arr){
    return prev+cur;
},10);
sum
//25
```