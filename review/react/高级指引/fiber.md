### 什么是Fiber

Fiber 是 React 16 中引入的调度器算法，用于优化渲染性能。

### 什么是Fiber节点

Fiber节点是React Fiber架构中用来分解和管理渲染任务的“最小单位”。这种方式可以避免长时间占用主线程，从而提高应用程序的响应性和性能。

在 React 中，每个组件都有一个对应的 Fiber 节点。

Fiber 节点存储了组件的状态、属性、类型以及对应的 DOM 节点等信息。

Fiber 节点构成Fiber树。

### Fiber的更新

#### 更新的产生

当调用 `setState` 或其他更新方法时，会触发状态更新。

React 会创建一个更新对象，该对象包含更新的状态、过期时间和优先级等信息。

该更新对象会被添加到对应 `fiber` 节点的更新队列的队尾。

#### 更新的类型

更新可以粗略分为同步更新和异步更新。不同类型的更新有不同的调度方式。

同时，同步更新和异步更新内部还可以进行细分。

不同的更新对应着不同的处理方式，比如会不会触发批处理模式。以及不同的优先级。不同的优先级又对应着不同的更新时间。

##### **同步更新**：

**事件处理：**

通常具有最高的优先级，React会立即处理这些更新。

**动画更新：**

js动画也具有较高的优先级，使得动画可以流畅执行。

为什么说是js动画呢？

而js动画是通过js控制dom的样式实现的，所以需要通过浏览器渲染进程的主线程去执行。

##### **异步更新**

**数据获取** ：

网络请求通常是异步的，React 会等待数据返回后再更新状态。

**离屏更新** ：

对于不可见的组件（例如滚动屏幕外的内容），它们的更新优先级通常是最低的，因为用户当前看不到它们的变化。

#### 更新的优先级

React内部有一个优先级系统，会根据不同类型的更新分配不同的优先级。

* **Immediate Priority** ：同步任务，无法中断。
* **User Blocking Priority** ：高优先级异步任务，可以被打断。
* **Normal Priority** ：普通异步任务，可以被更高优先级任务打断。
* **Low Priority** ：低优先级异步任务，更容易被打断。
* **Idle Priority** ：仅在主线程空闲时执行的任务。

通过这个优先级我们可以获取一个该更新必须执行的过期时间，优先级越高那么过期时间就越近，反之亦然。这个过期时间是用来判断该更新是否已经过期，如果过期的话就会马上执行该更新。

截止时间低的一般在浏览器的主线程空闲时才执行。

一般分为同步更新和异步更新，同步更新和异步更新中的事件也有相应的优先级。

#### 更新的过期时间

过期时间基于当前时间和优先级计算。

优先级通过时间片来量化。即**过期时间为当前时间和时间片之和**

React 内部会定义不同优先级对应的时间片长度。例如：

```js
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250; // 250ms
const NORMAL_PRIORITY_TIMEOUT = 5000; // 5s
const LOW_PRIORITY_TIMEOUT = 10000; // 10s
const IDLE_PRIORITY_TIMEOUT = Infinity;

```

React 会根据当前时间和对应的时间片长度来计算过期时间。例如，对于用户交互事件（假设优先级为 `USER_BLOCKING_PRIORITY`）：

#### **更新队列**

存储位置：每个Fiber节点中

存储单元：Fiber的每个更新

创建：在更新被创建时，会附带一个过期时间。这个过期时间用来确定更新的优先级。过期时间的产生下面会讲。

入队：更新会被放入同步更新队列队尾。

处理更新：

- 当需要调度时，调度器会携带一个此次渲染的时间，遍历更新队列。
- 调度器基于上次Fiber的state，把符合条件的更新都在state上进行应用，并移出队列。等全部应用完成，再把Fiber的state替换成这个新的state。

### Fiber的任务

#### 任务的产生

在调度阶段，会遍历Fiber树。（以什么形式遍历，是一整棵树还是一部分树我们之后再讨论）

当发现Fiber的更新队列存在时，就会**根据更新队列和最早的更新时间创建一个任务**。

```js
// 合成任务的函数
function createTask(expirationTime) {
  return {
    expirationTime,
    updates: [],
  };
}

// 在调度阶段合成任务
function createTaskFromUpdates(updates) {
  //这里的updates是单个fiber节点的更新队列
  let earliestExpiration = NoWork;
  for (const update of updates) {
    if (update.expirationTime < earliestExpiration) {
      earliestExpiration = update.expirationTime;
    }
  }
  const task = createTask(earliestExpiration);
  task.updates = updates;
  return task;
}
```

#### 任务的优先级 & 过期时间

这一块比较复杂。放在一起讲。

1. 任务生成时，从更新队列中获取最早的 `expirationTime`。
2. 任务的优先级基于这个 `expirationTime`计算。`expirationTime`与**当前时间**的差异越小，任务优先级越高，越早执行。
3. 在调度任务时，根据任务的优先级进一步调整任务的 `expirationTime`，计算出最终的 `renderExpirationTime`，这确保了高优先级任务能按时执行。

#### 任务的类型

同步任务和异步任务是根据任务的优先级进行划分的。

##### 同步任务

同步任务是立即执行的任务，它的优先级最高，立即执行，不允许中断，在当前的事件循环中完成。

常见的同步任务场景包括：

用户交互事件（如 onClick、onChange）会触发状态更新。
使用 ReactDOM.flushSync() 强制同步渲染更新。

##### 异步任务

异步任务由调度器进行调度，它们会进入任务队列，并根据优先级来决定执行顺序。异步任务可以被中断和恢复，这使得 React 可以通过时间切片技术来处理长时间运行的任务，同时允许处理高优先级任务。

异步任务通常涉及以下场景：

* **渲染更新** ：React 会将渲染更新任务标记为异步任务。
* **时间切片** ：React Fiber 架构允许将渲染任务分割为多个小的可中断单元，每个时间切片处理一部分任务。

#### 任务队列

存储位置：全局

存储单元：异步任务

除了同步任务，每个优先级的任务都会有一个对应的任务队列，调度器会根据任务的优先级将任务放入不同的队列中。然后按任务过期时间进行升序排序，这样每次都可以取出最早的任务。

调度器运行时，会优先执行高优先级的队列任务，直到队列为空或任务被打断，然后继续处理下一个优先级的任务。

# 任务的执行

## 是什么

任务执行是指React处理任务内容，如执行计算、更新DOM等操作。

任务调度是确定何时应该执行一个任务的过程。它是由调度器负责的，其核心工作是根据任务的优先级和过期时间来决定任务何时运行。

## 怎么做

### 同步任务

同步任务在产生后立刻执行。

**ReactDOM.flushSync** ：它强制同步执行任务，不允许任务被延迟到下一个事件循环。例如，当调用 `flushSync` 时，React 不会等待任何时间切片，而是立刻执行更新任务。执行任务的具体过程放在异步任务中讲。

```js
ReactDOM.flushSync(() => {
  setState({ count: count + 1 });
});

```

   这里的 `flushSync` 会强制在当前事件循环中执行 `setState`，并立即触发渲染，不会让该更新被异步调度。

### 异步任务

调度器会将任务分配到不同的优先级队列（如 `NormalPriority`、`UserBlockingPriority` 等）。

#### 工作循环

工作循环会从队列中取出任务，准备执行。

在源码中，主要由 `performWorkUntilDeadline` 方法控制工作循环。

如果当前没有其他任务在执行，工作循环会立刻开始执行优先级最高的任务。

工作循环在执行任务时，会不断调用 `performUnitOfWork` 来处理 Fiber 节点。对于每个 Fiber 节点，React 会处理对应 `Fiber` 节点上的 `updateQueue`，根据 `renderExpirationTime` 判断 `updateQueue`中的哪些update需要立刻应用。当发现节点需要更新，就会创建出一个镜像fiber节点。接着把镜像fiber节点中旧的state根据这些update生成新的state。

同时在任务执行中会发生任务的中断和恢复。

#### 时间分片

##### 是什么

时间分片是异步任务的调用机制，基于浏览器提供的 requestIdleCallback API。该API允许开发者在浏览器的空闲时段执行任务。

##### 怎么做

###### 时间片的执行：

* 时间分片的执行是在主线程上进行的，一个时间片长度通常为5～16ms，是动态分配的，依赖于任务的优先级和浏览器的帧时间。

###### 时间片的中断

**中断机制** ：

- React 在每个时间片的过程中会检查当前帧的剩余时间，如果帧时间快用完，会暂停当前任务以确保不会阻塞浏览器的渲染。

**中断条件** ：

* 当时间片耗尽时，任务被自动中断。
* 如果更高优先级的任务到达，React 会立即中断当前任务，转而执行高优先级任务。
* React 将中断的任务标记为“暂停”（paused）

###### **任务的中间状态** ：

- 任务的状态会被保存在 Fiber 树中，包含 `pendingProps`、`memoizedProps` 和 `alternate`。

###### **时间分片的恢复** ：

- 时间分片的恢复只有一种情况，当前任务为最高优先级，被重新调度。恢复时，React 会从 Fiber 节点的 `alternate` 属性中恢复到之前的状态，并继续执行任务。
  - 任务因时间分配耗尽中断，当前任务如果不是最高优先级，不会恢复
  - 任务因被高优先级任务打断中断，当前任务如果不是最高优先级，不会恢复

* 具体来说，React 使用了 `requestIdleCallback` 或者 `requestAnimationFrame` 来安排下一次的任务执行。这些 API 可以在浏览器空闲时调度任务，从而实现任务的分片执行。
* 如果浏览器不支持 requestIdleCallback，React 会回退到使用 setTimeout 来模拟相同的行为。

# 任务的Commit

当任务执行完成之后，React 会进入 Commit 阶段。React 会把镜像 Fiber 节点替换到当前的 Fiber 树上，生成一棵新的 Fiber 树。

# 任务的渲染

接着，React 使用 `requestAnimationFrame` 确保在下一帧之前，将新生成的 Fiber 树所代表的变化反映到真实的 DOM 上，完成渲染。这是一个同步过程，无法被中断。

渲染最终触发的条件是任务的完成状态和浏览器的帧管理机制：

* **高优先级任务完成后** : 如果高优先级任务（如用户输入）完成，并且时间允许，React 会立即进入 Commit 阶段进行渲染。
* **低优先级任务完成后** : 低优先级任务可能会被分成多个时间片执行。当这些任务执行完成后，如果时间允许，React 也会进入 Commit 阶段。
* **浏览器下一帧绘制之前** : React 通常会在浏览器即将进行下一帧绘制之前，通过 `requestAnimationFrame` 来触发渲染，确保 DOM 更新与绘制同步，从而避免用户界面出现闪烁或不一致。
* **强制更新** : 某些情况下，React 可能会在特定事件（如用户强制刷新）后立即触发渲染，无论是否还有未完成的低优先级任务。

# 批处理模式

## 是什么

**批处理模式** 是 React 的优化性能的机制。

在批处理模式下，React 会将多个状态更新（`setState`）或其他更新操作（如 `useReducer` 的 `dispatch`）合并在一起，延迟到一个批次中统一执行，而不是逐一同步处理每个更新。

同时任务也会进行批处理，开启批处理模式之后会把多个任务进行合并处理。

> 批处理模式下更新也会入队，但是其实这没什么必要，因为更新会被立刻创建为任务。入队是为了保持代码逻辑上的一致性。

## 为什么

* **优化性能** ：批处理模式减少了在同一帧内多次渲染的可能性，从而降低了浏览器的负载，尤其是在复杂组件或应用中，性能提升尤为明显。
* **一致性** ：在同一批次中的所有更新被视为一个事务，避免出现中间状态。

## 开启时机

批处理模式大多在React的控制范围内自动开启，如事件处理和生命周期函数中。也可以通过 `unstable_batchedUpdates` 手动开启。

当开启批处理模式时，全局的isBatchingUpdates标识被置为true。

## 关闭时机

- 原生 DOM 事件处理程序：如直接通过 `addEventListener` 绑定的事件处理器。
- 非 React 管理的环境中进行的状态更新： setTimeout 或 setInterval 回调中。
- 手动控制：你可以通过 `flushSync` 强制让 React 立即渲染，而不等待批处理。这样做会关闭当前批处理机制。

## 批处理模式&非批处理模式总流程对比（调用setState之后会发生什么）

### **触发更新**

当用户触发更新（例如 `setState`）时，React 会创建一个 `update` 对象，并将其加入到触发更新的 Fiber 节点的 `updateQueue` 中。

### **Fiber 树的遍历和标记**

**非批处理模式** :

* 更新触发后，React 会立即从触发更新的 Fiber 节点开始，自下而上遍历 Fiber 树。
* 在遍历过程中，React 对每个沿途的 Fiber 节点进行标记，标识这些节点需要在当前任务中被处理。
* 这种标记是立即执行的，React 之后会直接进入任务调度阶段，执行这些更新。

**批处理模式** :

* 更新触发后，React 不会立即执行标记和渲染，而是将更新放入 `updateQueue` 中。
* Fiber 树不会立刻进行自下而上的遍历，标记也不会立即发生。相反，React 会等待批处理结束时，才开始标记过程。

### **生成任务并放入任务队列**

**非批处理模式** :

* 在 Fiber 树标记完成后，React 会立即生成一个任务，该任务代表此次更新对应的工作，并将其放入任务队列。
* 任务生成后，React 会立即开始调度这个任务，并执行它。

**批处理模式** :

* 在批处理模式下，React 会在批处理结束时，对所有触发更新的 Fiber 节点统一处理。
* 批处理结束后，React 开始自下而上遍历 Fiber 树，对需要更新的 Fiber 节点进行标记。
* 对每个被标记的 Fiber 节点，React 会生成一个任务，这个任务会包含该节点的 `updateQueue` 中的更新。

### **调度任务**

任务根据优先级分为同步任务和异步任务。

同步任务与异步任务有不同的调度和执行机制。

同步任务立刻执行。

异步任务会进入任务队列。任务被放入队列后，React 会根据任务的优先级来调度执行。执行任务时会发生任务的打断与恢复。

### 执行任务

执行过程中，React 会处理每个任务所包含的 `updateQueue`。构建对应的镜像Fiber节点（工作树节点），并对其进行更新。

### Commit

当任务执行完成之后，React 会进入 Commit 阶段。React 会把镜像 Fiber 节点替换到当前的 Fiber 树上，生成一棵新的 Fiber 树。

### 渲染

接着，React 使用 `requestAnimationFrame` 确保在下一帧之前，将新生成的 Fiber 树所代表的变化反映到真实的 DOM 上，完成渲染。这是一个同步过程，无法被中断。

### **关键区别**

在 **非批处理模式** 中，更新触发后立即标记 Fiber 节点，并立即生成和执行任务。

在 **批处理模式** 中，更新触发后不会立即标记，而是等批处理结束后，再统一标记、生成任务并执行。

标记和任务生成的顺序取决于是否启用了批处理模式。如果有批处理，标记和任务生成是延迟的，等待批处理结束时才进行；如果没有批处理，标记和任务生成是同步进行的。

# 关键浏览器api

在 React 的 Fiber 架构中，`requestIdleCallback` 和 `requestAnimationFrame` 是两个关键的浏览器 API，它们在不同的情况下发挥作用，以确保 React 在执行任务时既高效又能保持 UI 的流畅性。

### 1. **`requestIdleCallback`**

* **时间分片** : 在并发模式下，React 会将低优先级任务分成小的时间片，通过 `requestIdleCallback` 来执行这些任务，从而避免阻塞 UI 渲染这种高优先级任务。

### 2. **`requestAnimationFrame`**

`requestAnimationFrame` 的主要作用是让浏览器在下一帧刷新之前执行指定的回调函数，这样可以确保所有的 DOM 操作都在浏览器的刷新周期内完成。通过在下一帧之前完成绘制，`requestAnimationFrame` 可以有效避免重绘过程中出现的闪烁或抖动问题。

# fiber为什么设计成双向链表

双向链表允许在 Fiber 树中进行高效的双向遍历。这是因为每个节点不仅有指向下一个节点的指针（`next`），还有指向上一个节点的指针（`prev`）。这使得在 Fiber 树的插入、删除或移动节点变得更加方便。例如，在执行 Fiber 树的 diff 和 update 操作时，可以利用双向链表的双向遍历来高效地找到并处理需要更新的节点。
