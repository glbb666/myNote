## 大致流程

1. URL 解析
2. DNS 解析获取对应IP（如果输入的是IP地址，此步骤省略）
3. 根据IP建立TCP 连接（三次握手）
4. 发起HTTP请求
5. 服务器处理HTTP请求，浏览器接受响应
7. 客户端渲染
8. 关闭TCP连接（四次挥手）

## 一、URL 解析

**地址解析：**

首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动补全、字符编码等操作。

**HSTS**

由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：[你所不知道的 HSTS](https://www.barretlee.com/blog/2015/10/22/hsts-intro/)。

**其他操作**

浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。

**检查缓存**

先检查本地有没有缓存，如果没有缓存则向服务器请求数据，如果有缓存，检查缓存有没有过期，如果缓存没有过期，就命中强缓存，如果缓存过期了，就携带标识向服务器发起请求，服务器会根据标识判断资源有没有被修改过，如果被修改了，就返回200和缓存标识和资源主题，否则返回304，让你使用本地缓存。

![img2]([https://github.com/glbb666/myNote/blob/master/review/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/image/cache2.png](https://github.com/glbb666/myNote/blob/master/review/网络安全/image/cache2.png))

![cache2](G:\WebstormProjects\myNote\review\网络安全\image\cache2.png)

## 二、DNS 解析获取对应IP

- 浏览器**根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则，浏览器会在操作系统缓存中（包括本机的 hosts文件）查找有没有对应的域名映射。
- 如果浏览器缓存和操作系统中均无该域名的dns解析记录，或者已经过期，**操作系统**将域名发送至 本地 DNS服务器，让本地域名服务器尝试解析
- 如果**本地 DNS 服务器**没有缓存不能直接将域名转换为 IP 地址，需要采用递归或者迭代查询的方式依次向**根域名服务器**、**顶级域名服务器**、**权威域名服务器**发起查询请求
- 本地域名服务器 将得到的<font color='red'> 该域名对应的IP和TTL值</font>返回给操作系统，同时会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址根据TTL值缓存在本地系统缓存，以备下次别的用户查询时，可以直接返回结果，加快网络访问。
- 至此，浏览器已经得到了域名对应的 IP 地址。

## 三、根据IP建立TCP 连接（三次握手）

1. 客户端把一个**`标志位SYN`置为1，序号seq为随机值J**的数据包发送到服务器，请求建立连接，同时客户端进入**`syn_sent`**半打开状态，等待服务器确认
2. 服务端收到数据包后由**`标志位SYN`=1**知道客户端请求建立连接，服务端进入**`syn_rcvd`**半打开状态。服务端将一个**`标志位SYN和ACK`都置为1，ack=J+1，序列号seq为随机值K**的数据包发送给客户端，以确认连接请求
3. 客户端接收到服务器的SYN+ACK包，检查ack是否为J+1，ACK是否为1，如果正确，客户端进入**`establish`**状态。接着，客户端将一个**`标志位ACK置为1`，ack=K+1**的数据包发送给服务端。
4. 服务端接收到确认后，检查ack是否为K+1，ACK是否为1，如果正确，服务端变为**`establish`**状态。连接建立成功。

![img](http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png)

![img](<https://github.com/glbb666/myNote/blob/master/review/网络安全/image/tcp1.png>)

>SYN:synchronous   建立连接
>ACK:acknowledgement  确认
>SYN_SENT:请求连接
>SYN_RECV:服务端被动打开后，接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。

**syn_sent**是主动打开方的「半打开」状态，**syn_rcvd**是被动打开方的「半打开」状态。**客户端是主动打开方，服务器是被动打开方**。

💥注意：**tcp在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送**。

## 四、发起HTTP请求

根据解析出的IP地址+端口，构建HTTP请求报文并通过TCP协议发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。

HTTP请求报文是由三部分组成: **请求行**, **请求报头**和**请求正文**。

#### 请求行

`Method Request-URL HTTP-Version CRLF`

```
eg: GET index.html HTTP/1.1
```

常用的方法有: `GET`,` POST`, `PUT`,` DELETE`,` OPTIONS`, `HEAD`。

🌟`GET`和`POST`有什么区别？

#### 请求报头

请求报头允许客户端向服务器传递请求的**附加信息**和**客户端自身的信息**。

常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。

#### 请求正文

当使用`POST`, `PUT`等方法时，通常需要客户端向服务器传递数据。这些**数据就储存在请求正文**中。在请求包头中有一些与请求正文相关的信息，例如: 现在的`Web`应用通常采用`Rest`架构，请求的数据格式一般为`json`。这时就需要设置`Content-Type: application/json`。

## 五、服务器接受HTTP请求，浏览器响应

后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。

HTTP响应报文也是由三部分组成: **状态码**, **响应报头**和**响应报文**。

#### 状态码

状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。
  平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。

🌟301和302有什么区别？HTTP缓存？

#### 响应报头

常见的响应报头字段有: Server, Connection...。

#### 响应报文

服务器返回给浏览器的文本信息，通常`HTML`, `CSS`,` JS`， 图片等文件就放在这一部分。

## 六、客户端渲染

浏览器是一个边解析边渲染的过程。

- 处理 `HTML` 标记并构建 `DOM` 树
- 处理 `CSS` 标记并构建 `CSSOM` 树
- 将 `DOM` 与 `CSSOM` 合并成一个渲染树
- 根据渲染树来布局，以计算每个节点的位置大小信息
- 将各个节点绘制到屏幕上

这个过程比较复杂，涉及到两个概念: `reflow`(回流)和`repain`(重绘)。

回流：当渲染树中部分或全部元素的**尺寸、结构、或某些属性**发生改变时，浏览器重新渲染部分或全部文档的过程

重绘：当页面中元素样式的改变并**不影响它在文档流中的位置**时（例如：`color`、`background-color`、`visibility`等），浏览器会**将新样式赋予给元素并重新绘制它**。

通常情况下`DOM`和`CSSOM`是并行构建的，但是当浏览器遇到一个不带`defer`或`async`属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成`CSSOM`的下载和构建，由于JavaScript可以修改`CSSOM`，所以需要等`CSSOM`构建完毕后再执行`JS`，最后才重新开始`DOM`构建。

## 七、关闭TCP连接（四次挥手）

1. 客户端把一个**`标志位FIN`置为1，序号seq为随机值M**的数据包发送到服务器，用来关闭客户端到服务器的数据传送，客户端进入**`fin_wait_1`**状态 
3. 服务器收到客户端的**`fin`**包，把一个**`标志位ACK置为1`，ack=M+1**的数据包发送给客户端，服务端进入**`close_wait`**状态
3. 客户端接收到服务器的**`ack`**包，检查**`ack`**是否为M+1，**`ACK`**是否为1，如果正确，客户端进入**`fin_wait_2`**状态
4. 服务器把一个**`标志位FIN`置为1，序号`seq`为随机值N**的数据包发送到客户端，用来关闭服务器到客户端的数据传送，服务器进入到**last_ack**状态
5. 客户端收到服务器的fin包，把一个**`标志位ACK置为1`，ack=K+1**的数据包发送给客户端，客户端进入time_wait状态，在2MSL之后进入**`closed`**状态
6. 服务器收到客户端的包，进入**`closed`**状态

![img](http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png)