[前端缓存最佳实践](https://juejin.im/post/5c136bd16fb9a049d37efc47#heading-3)

## 强缓存和协商缓存

浏览器缓存机制主要分为两大类型：强缓存和协商缓存。它们共同目标是减少不必要的网络请求，加快页面加载速度，并减轻服务器负担。

* **强缓存** ：不会向服务器发送请求，直接从浏览器缓存或者代理服务器缓存中读取资源。强缓存的判断主要依赖于 `Cache-Control` 的 `max-age` 和 `Expires` 头。如果指定的时间还没到期，或者没有设定 `Cache-Control`为 `no-store`或者 `no-cache`，就使用强缓存。
  * CDN就是代理缓存的一种
* **协商缓存** ：浏览器会向服务器发送请求，带有 `If-None-Match`（携带 `ETag` 值）或 `If-Modified-Since`（携带上次返回的 `Last-Modified` 时间）。服务器根据这些头部值判断资源是否更新。
  * 如果资源未更新，服务器返回 `304 Not Modified` 响应，告诉浏览器可以使用缓存的资源。
  * 如果资源已更新，服务器返回 `200 OK` 状态码及新的资源内容。

## 什么时候使用强缓存，什么时候使用协商缓存

走不走缓存，什么时候走强缓存，什么时候走协商缓存，由HTTP版本，cache-control和expires决定的。这些字段和get请求一起构成了浏览器的缓存机制。

在HTTP1.0版本中由expries决定。一般是缓存没过期走强缓存，缓存过期了走协商缓存。

在HTTP1.1及其以上版本中exprires和cache-control一起决定，且cache-control优先。

cache-conntrols对缓存的使用，缓存的变化控制的更精细。一般来说，如果设置了no-store就不走缓存，设置了no-cache走协商缓存，在其他的情况下，缓存未过期走强缓存，缓存已过期走协商缓存。缓存的过期由浏览器和服务器共同决定，且服务器优先。

## 缓存使用的实践

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。

在更新版本之后，可以把静态资源的路径改了，达到绕过缓存的目的。

 `webpack`支持在打包的时候，在文件的命名上带上hash值。

```javascript
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}
```

综上所述，我们可以得出一个较为合理的缓存方案：

- `HTML`：使用协商缓存，每次都能拿到最新的 `html`资源。
- `CSS`&`JS`&图片：使用强缓存，文件命名带上 `hash`值，改变资源路径。

## 哈希也有讲究

`webpack`给我们提供了三种哈希值计算方式，分别是 `hash`、`chunkhash`和 `contenthash`。那么这三者有什么区别呢？

- `hash`：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的 `hash`值都会更改。（项目的所有文件，文件名都带上一个 `hash`）
- `chunkhash`：根据不同的入口文件(`Entry`)进行依赖文件解析、构建对应的 `chunk`，生成对应的 `hash`值。（项目相同入口的文件，文件名都带上一个 `hash`）
- `contenthash`：由文件内容产生的 `hash`值，内容不同产生的 `contenthash`值也不一样。(项目的每一个文件都根据自己的内容拥有自己的的 `hash`)

显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的hash都变了，缓存自然都失效了。这不是我们想要的。

那 `chunkhash`和contenthash的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的css都抽离出对应的css文件来加以引用。如果我们使用chunkhash，当我们改了css代码之后，会发现css文件hash值改变的同时，js文件的hash值也会改变。这时候，contenthash就派上用场了。

## 缓存的位置

在cache-control中我们知道，缓存分为public和private。public属于代理缓存，provate属于浏览器缓存。

### 代理缓存

存储在网络上的某个中间代理服务器上。

#### 为什么使用代理服务器

* **减轻原始服务器的负担**
* **加快响应速度** ：对于地理位置较远的用户，如果代理服务器距离他们更近，那么从代理服务器获取缓存的资源会比从原始服务器获取更快
* **节省带宽** ：尤其在一个网络环境中，若多个用户请求相同资源，代理服务器可以提供这些资源的缓存副本，减少对原始服务器的重复请求，从而节省了互联网上的带宽使用。

### 浏览器缓存

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

#### Service Worker

Service Worker 能够实现类似代理服务器的缓存行为。可以称为Service Worker Cache

Service Worker 运行在独立的进程中。允许开发者通过脚本在浏览器背后捕获、处理、自定义网络请求和响应的行为，包括管理缓存内容。

详细在浏览器/WebWorker&ServiceWorker&SharedWorker中

#### Memory Cache （内存缓存）

内存缓存是浏览器为加快资源加载速度而将资源暂时存储在内存中的一种策略。由于存储在内存中，读取速度非常快，但它是易失的，通常**在页面会话结束时被清除**，或者由于系统内存压力而被清理掉。

* **优先级** ：通常高，因为访问速度快，但易失性限制了它的使用场景。
* **使用场景** ：适用于存储页面**会话期间频繁访问且体积不大的资源**。

#### Disk Cache（磁盘缓存）

磁盘缓存将资源存储在硬盘上，虽然比内存缓存速度慢，但提供了更大的存储空间和持久性。这意味着即使在浏览器关闭后，缓存资源也依然存在，可以在后续的浏览器会话中使用。

* **优先级** ：相对于内存缓存而言，优先级低一些，因为访问速度慢。
* **使用场景** ：适用于大型、不太可能在短时间内被更改的资源。

#### Push Cache（推送缓存）

Push Cache 是HTTP/2的一个特性，允许服务器无需客户端请求即可“推送”资源到客户端缓存中。这种缓存是会话级别的，也就是说它只在当前会话中有效，并且不所有浏览器都实现了这一特性。

* **优先级** ：相对较低，因为它依赖于HTTP/2且是会话级别的。
* **使用场景** ：适用于预加载可能很快被需要的资源，以减少加载时间。

## 缓存图解

![cache2](images/cache2.png)
