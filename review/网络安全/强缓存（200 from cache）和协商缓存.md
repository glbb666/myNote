[前端缓存最佳实践](<https://juejin.im/post/5c136bd16fb9a049d37efc47#heading-3>)

## 强缓存和协商缓存

这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。

浏览器缓存主要有以下几个优点：

1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。
2. 降低服务器的压力，提升网站性能。
3. 加快客户端加载网页的速度， 提升用户体验。

两者的主要区别是**使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效**。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。

### 强缓存的问题

强缓存主要是通过`http`请求头中的`Cache-Control`和`Expire`两个字段控制。`Expire`是`HTTP1.0`标准下的字段。一般，我们会设置`Cache-Control`的值为`“public, max-age=xxx”`，表示在`xxx`秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。

显而易见，如果在`xxx`秒内，服务器上面的资源更新了，客户端在没有强制刷新的情况下，看到的内容还是旧的。如果发布新版本的时候，后台接口也同步更新了，有缓存的用户还在使用旧接口，而那个接口已经被后台干掉了。怎么办？

协商缓存每次都要向服务器验证一下缓存的有效性。

## 最佳实践（什么时候用强缓存，什么时候用协商缓存）

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。

在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。

伟大的`webpack`可以让我们在打包的时候，在文件的命名上带上hash值。

```javascript
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}
```

综上所述，我们可以得出一个较为合理的缓存方案：

- `HTML`：使用协商缓存，每次都能拿到最新的`html`资源。
- `CSS`&`JS`&图片：使用强缓存，文件命名带上`hash`值，改变资源路径。

## 哈希也有讲究

`webpack`给我们提供了三种哈希值计算方式，分别是`hash`、`chunkhash`和`contenthash`。那么这三者有什么区别呢？

- `hash`：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的`hash`值都会更改。（项目的所有文件，文件名都带上一个`hash`）
- `chunkhash`：根据不同的入口文件(`Entry`)进行依赖文件解析、构建对应的`chunk`，生成对应的`hash`值。（项目相同入口的文件，文件名都带上一个`hash`）
- `contenthash`：由文件内容产生的`hash`值，内容不同产生的`contenthash`值也不一样。(项目的每一个文件都根据自己的内容拥有自己的的`hash`)

显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的hash都变了，缓存自然都失效了。这不是我们想要的。

那`chunkhash`和contenthash的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的css都抽离出对应的css文件来加以引用。如果我们使用chunkhash，当我们改了css代码之后，会发现css文件hash值改变的同时，js文件的hash值也会改变。这时候，contenthash就派上用场了。

## 后端需要怎么设置

上文主要说的是前端如何进行打包，那后端怎么做呢？ 我们知道，**浏览器是根据响应头的相关字段来决定缓存的方案的**。所以，后端的关键就在于，根据不同的请求返回对应的缓存字段。 以nodejs为例，如果需要浏览器强缓存，我们可以这样设置：

```javascript
res.setHeader('Cache-Control', 'public, max-age=xxx');
```

如果需要协商缓存，则可以这样设置：

```javascript
res.setHeader('Cache-Control', 'public, max-age=0');
res.setHeader('Last-Modified', xxx);
res.setHeader('ETag', xxx);
```

## 缓存的位置

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

### Service Worker

Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。其中的`离线缓存`就是 **Service Worker Cache**。

Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。

### Memory Cache 和 Disk Cache

**Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

**Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：

- 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
- 内存使用率比较高的时候，文件优先进入磁盘

### Push Cache

即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇[扩展文章](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)

## 总结

在做前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加hash的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。

![cache2](images/cache2.png)

