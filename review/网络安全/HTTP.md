### `http`

超文本传输协议，它是一个**无状态**的**应用层**的协议，由请求和响应构成。

http报文分为两种类型，请求报文和响应报文。

#### 请求报文

当浏览器或其他客户端需要从服务器请求资源时，它会发送一个HTTP请求报文

- 请求行：请求类型（如 GET、POST），请求的URI，HTTP协议版本号。

  - 例如: `GET /index.html HTTP/1.1`
- 请求头：客户端环境信息、请求体的类型

  * `Host`: 服务器的域名或IP地址。
  * `User-Agent`: 客户端软件信息。
  * `Accept`: 客户端可接受的回应内容类型。
- 空行：分割请求头与请求体
- 请求体：可以添加任意的其他数据

#### 响应报文

当服务器处理完客户端请求后，它会返回一个HTTP响应报文

- 状态行：HTTP版本号、状态码（如200、404）、状态文本（如OK、Not Found）
  - 例如: `HTTP/1.1 200 OK`
- 响应头：包含服务器信息、内容类型、内容长度等
  * `Server`: 服务器软件信息。
  * `Content-Type`: 返回数据的MIME类型，等下详细讲。
  * `Content-Length`: 返回数据的长度（字节数）。
  * `Set-Cookie`: 服务器向客户端提供的Cookie等。
- 空行：分割请求头与请求体
- 响应体：返回给客户端的文本信息。对于一个网页请求，这里一般是HTML文本。

#### 共通使用的请求头，响应头

##### `Content-Type`

**请求头中的 `Content-Type`**

在HTTP请求头中，`Content-Type` 表明了请求体的媒体类型，这对于服务器正确解析请求体是非常重要的。特别是对于POST和PUT这类可以带有请求体的请求方法。例如，当你提交表单或通过API上传JSON数据时，客户端需要告诉服务器它正在发送什么格式的数据，以便服务器可以正确解析。

举例：

* `Content-Type: application/x-www-form-urlencoded`：这是最常见的数据提交方式，主要用于HTML表单提交。
* `Content-Type: multipart/form-data`：这种方式一般用于上传文件。
* `Content-Type: application/json`：指示请求体是JSON格式的字符串，这在现代Web API中极为常见。

**响应头中的 `Content-Type`**

在HTTP响应头中，`Content-Type` 起着告知客户端它收到的内容是什么格式的作用。这让客户端（如浏览器）知道如何解析和展示这些数据。例如，如果响应体是一个HTML文档，服务器会用 `Content-Type: text/html` 来告诉客户端；如果是一个JSON对象，使用 `Content-Type: application/json`。

正确的 `Content-Type` 能保证HTTP通信双方能够正确理解数据的含义和格式，因此是HTTP协议中非常重要的一部分。

##### Connection：

`Connection` 头在HTTP请求和响应头中起着关键的作用，虽然它在这两种情况下的基本目的相同

 `keep-alive` 和 `close`。`keep-alive` 指示希望保持连接开启，即长连接，以便重用于后续的请求和响应，以提高效率。`close` 则指示完成当前请求和响应后应关闭连接。

##### Cache-Control（这一块可以去缓存相关header去看）

##### User-Agent:

User-Agent主要是请求头。

* **内容协商** ：服务器可以根据 `User-Agent` 头返回最适合客户端的资源版本。例如，向手机浏览器提供一个与桌面浏览器不同的页面版本。
* **统计分析** ：服务器可以记录 `User-Agent` 数据用于分析网站的用户群体，比如哪种浏览器或操作系统最为常用。
* **兼容性工作** ：开发者可以使用 `User-Agent` 来决定是否使用某些针对特定浏览器的 CSS 样式或 JavaScript 代码。
* **防止机器人爬取** ：一些服务器会检查 `User-Agent` 字符串来区分人类用户和网络机器人。
  * 知名的搜索引擎爬虫（如 Googlebot、Bingbot 等）都会在其 `User-Agent` 字符串中明确标识自己。服务器可以通过匹配已知爬虫的 `User-Agent` 列表来识别它们。
  * 某些爬虫可能没有明确的身份标识，但它们的 `User-Agent` 字符串可能包含像 “bot”、“crawler” 或 “spider” 这样的关键词。

有些情况下，服务器或中间件可能会将 `User-Agent` 放回到 HTTP 响应头中

#### 常用的请求头

If-Modified-Since

If-Unmodified-Since

这俩都属于协商缓存的范畴，见缓存相关header

#### 常用的响应头

Last-Modified

ETag

这俩都属于协商缓存的范畴，见缓存相关header

#### HTTP 方法

- GET：获取资源
- POST：传输资源
- PUT：更新资源
- DELETE：删除资源
- HEAD：获取报文首部

#### get和post的区别

- 目的：`GET`**请求数据**，`POST` **提交数据**。
- 缓存性：`Get`请求能缓存。 `Post`不能。这和协商缓存中 `If-Since-Modified`和 `If-None-Match`这俩请求头的特性也有关。
- 安全性：`Post`相对 `Get`相对安全一些，因为 `Get`请求都包含在 `URL`中，而且会被浏览器保存记录，Post不会。但是再抓包的情况下都是一样的。
- 数据大小：`Get `请求可以传输的数据更少，因为 `URL`有长度限制，`Post` 可以通过请求头来传输比 `Get`更多的数据
- 数据类型：`Post` 支持更多的编码类型且不对数据类型限制

#### get请求能传图片吗

图片一般有两种传输方式：`base64` 和 `file` 对象

`base64` 的本质是字符串，而 `GET` 请求的参数在 `url` 里面，所以直接把图的 `base64` 数据放到 `url` 里面，就可以实现 `GET` 请求传图片。

但是 `GET` 请求的 `url` 长度会被浏览器限制，最长的大概是 `10k` 左右，根据 `base64` 的编码原理，`base64` 图片大小比原文件大小大 1/3，所以说 `base64` 只能传一些非常小的小图，大图的 `base64` 太长会被截断。

## [http状态码](https://www.runoob.com/http/http-status-codes.html)（重点会让你解释304状态码）

HTTP状态码共分为5种类型：

- 1**	**信息**，服务器收到请求，需要请求者**继续执行**操作
- 2**	**成功**，操作被成功接收并处理
- 3**	**重定向**，需要进一步的操作以完成请求
- 4**	**客户端错误**，请求包含语法错误或无法完成请求
- 5**	**服务器错误**，服务器在处理请求的过程中发生了错误

### 常用的几个状态码

- 100 继续请求
- 200 请求成功，响应体随之返回。
- 204 无内容。服务器成功处理，但未返回内容。
- 301 永久重定向
- 302 暂时重定向
- 304 未修改。适用于协商缓存。服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
- 400 1、客户端请求的语法错误，服务器无法理解（数据类型不一致，如Content-Type不匹配）2、请求参数有误
- 401 未认证，请求要求用户的身份认证，如token不存在就会报错。
- 403 服务器理解请求客户端的请求，但是拒绝执行此请求。如没有权限就会报错。
- 404 请求的资源（网页等）不存在。不能确定资源是永远或临时的丢失。
- 410 说明请求的内容在服务器上永久丢失了
- 412 表示客户端请求中所指定的一种或多种前置条件评估为false时，服务器无法处理该请求。常常出现于使用协商缓存请求头的情况
- 422 语义错误
- 500 服务器错误
- 504 服务器超时

### 301和302的区别

#### 1. 定义

**301** 表示资源已永久移动到新位置，将来任何对该资源的引用都应该使用新的 URI。这是告诉客户端和搜索引擎该资源的新位置永久性质的一种方式。

**302** 表示资源临时移动到另一个 URI，客户端应该对未来的请求仍使用原始 URI。

#### 2. 缓存

对于 `301`请求，浏览器是默认可缓存，除非指定了不同的缓存指令，因为它告诉客户端和搜索引擎原始资源已经被永久移动。

而 `302`，默认情况下是不可缓存的，除非明确指定了缓存指令（通过 `Cache-Control`或 `Expires`头部），因为它代表的是一种临时的重定向状态。

#### 3. 搜索引擎

**301** 重定向会导致搜索引擎更新它们的索引，将旧地址替换为新地址，并将链接的权重和排名转移给新地址。

**302** 重定向时，搜索引擎会抓取新的内容但仍然保留旧的 URL 在其索引中。这意味着搜索引擎认为旧地址仍是有效并偏好的 URI。

#### 4. 安全和网址劫持

使用**301**重定向可以避免网址劫持问题。

**这是因为302**重定向由于其临时性质，可能导致搜索引擎保留原始的 URL。不良行为者可能把临时重定向指向目标网站，借助目标网站的内容获取搜索排名或流量。这类“URL 劫持”问题定期监控外部链接到网站的行为来避免。

比如说，A -> B，有的时候A 网址很短，而B 网址是一个很长的乱七八糟的URL 网址，A 网址更加用户友好。这时搜索引擎很有可能会仍然显示网址A。也就是说，一个不道德的人在他**自己的网址A 做一个302 重定向到你的网址B**，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。

## `HTTP1.0 HTTP 1.1`主要区别

[HTTP1.0 HTTP 1.1 HTTP 2.0主要区](https://blog.csdn.net/linsongbin1/article/details/54980801)
[如何优雅的谈论HTTP／1.0／1.1／2.0]([https://www.jianshu.com/p/52d86558ca57)

- 长连接：HTTP/1.1支持长连接（默认情况下），在一个TCP连接上可以传送多个HTTP请求和响应，这显著减少了因频繁建立和关闭TCP连接所产生的开销和延迟，但是同一时刻只能有一个 `http`请求。HTTP/1.0需要显式使用 `Connection: keep-alive`头部来启用长连接。
- 优化的缓存处理：HTTP/1.1引入了更复杂的缓存控制机制，比如 `ETag`、`If-Modified-Since`。这些改进使得缓存更有效，减少不必要的数据传输。
- host：host头其实是客户端用来区分网站host域，方便服务器识别的。当用户输入URL，会进行DNS解析，拿到IP，IP寻址，寻的是服务器的地址。
  - 在HTTP1.0时代，一个服务器只能挂一个网站，因为一个服务器只能托管一个ip，但是这样做太浪费了，所以可以通过一些方法绕过，在一个服务器跑多个网站，比如通过区分端口号的方式，但是这些方法毕竟不够正规
  - 在HTTP1.1中，这些人们常用的行为被融入到规范中，更加语义化了，因此出现了host头，这样服务器可以简单的通过host头去区分，返回不同的网页
- 请求方法 ：HTTP/1.1增加了一些新的请求方法（如 `OPTIONS`、`PUT`、`DELETE`等），使得HTTP协议不仅局限于获取数据(`GET`)或提交数据(`POST`)，还可以执行更复杂的操作。

## `HTTP1.1` `HTTP 2.0`主要区别

- 多路复用
  **每个域名的请求在一个TCP连接中**，互不干扰。
  - HTTP2.0引入了"流"的概念，一次完整的请求-响应过程称为一个流。这是因为流就是为了多路复用产生的，1.0的一次性连接和1.1的顺序连接不需要流对请求-响应的模式进行标记。
  - 帧是HTTP2.0通信中的最小单位，帧有一个"流标识符"，标识帧属于哪个流
- 二进制传输
  HTTP/2引入了二进制分帧层。二进制分帧层只是一个概念。它指的就是帧在流中传输的这个行为。二进制分帧层支持把数据分割，用二进制编码，并行传输。
- 首部压缩
  `HTTP2.0`使用 `HPACK`算法对 `header`的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
- 服务端推送
  服务器可以对客户端的**一个请求发送多个响应**。服务器推送基于多路复用，并且服务器推送可缓存。具体缓存规则见浏览器缓存机制。

## 总结：HTTP从1.0->1.1->2.0

- 连接上：默认短连接(1.0)->默认长连接(1.1)->多路复用(2.0)
- 新增请求：如 `OPTIONS`、`PUT`、`DELETE`等(1.1)
- host：无->有(1.1)
- 文件传输(1.0,1.1) -> 二进制传输（2.0)
- 服务器推送(2.0新增)
- 首部压缩(2.0)
