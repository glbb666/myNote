## `http`

超文本传输协议，它是一个**无状态**的**应用层**的协议，由请求和响应构成。


#### 请求报文

- 请求行：请求类型，要访问的资源，HTTP协议版本号
- 请求头：用来说明服务器要使用的附加信息（一些键值对），例如：User-Agent、 Accept、Content-Type、Connection
- 空行：分割请求头与请求体
- 请求体：可以添加任意的其他数据

#### 响应报文

- 状态行：状态码，状态消息，HTTP协议版本号
- 响应头：说明客户端要使用的一些附加信息，如：Content-Type、charset、响应的时间
- 响应体：返回给客户端的文本信息

#### 常用的`http`请求头

##### Connection： `keep-alive/close`，使用`keep-alive`，`TCP`连接为长连接，一个长连接上可以传送多个`http`请求和相应。

##### User-Agent: 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

##### Cache-Control

- **Cache-Control:private** 默认为private  响应只能够作为私有的缓存，不能被代理服务器缓存。
- **Cache-Control:public** 响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
- **Cache-Control:no-cache**  不管本地缓存有没有过期，使用缓存前都要和源服务器进行有效性校验。
- **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
- **Cache-Control:no-store** 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。
- **Cache-Control:must-revalidate**  响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。

##### Cookie

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

## HTTP 方法

- GET：获取资源
- POST：传输资源
- PUT：更新资源
- DELETE：删除资源
- HEAD：获取报文首部

#### get和post的区别

- 目的：GET**请求数据**，POST **提交要被处理的数据**。
- 缓存性：`Get`请求能缓存，`Post`不能，GET在浏览器回退时是无害的，而POST会再次提交
- 安全性：`Post`相对`Get`相对安全一些，因为`Get`请求都包含在`URL`中，而且会被浏览器保存记录，Post不会。但是再抓包的情况下都是一样的。
- 数据大小：`Get `请求可以传输的数据更少，因为`URL`有长度限制，`Post` 可以通过请求头来传输比`Get`更多的数据
- 数据类型：`Post` 支持更多的编码类型且不对数据类型限制
- 对于部分浏览器和框架来说，对于`GET`方式的请求，浏览器会把`header`和`data`一并发送出去；而对于`POST`，浏览器先发送`header`，服务器响应`100 continue`，浏览器再发送`data`。

## [http状态码](https://www.runoob.com/http/http-status-codes.html)（重点会让你解释304状态码）

HTTP状态码共分为5种类型：

- 1**	**信息**，服务器收到请求，需要请求者**继续执行**操作
- 2**	**成功**，操作被成功接收并处理
- 3**	**重定向**，需要进一步的操作以完成请求
- 4**	**客户端错误**，请求包含语法错误或无法完成请求
- 5**	**服务器错误**，服务器在处理请求的过程中发生了错误

### 常用的几个状态码

- 100 继续请求
- 200 请求成功
- 204 无内容。服务器成功处理，但未返回内容。
- 301 永久重定向
- 302 暂时重定向

注意：这里可以说一说301和302的区别。

- 304 **<font color='red'>未修改</font>**。缓存。服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
- 400 1、客户端请求的语法错误，服务器无法理解（数据类型不一致，如Content-Type不匹配）2、请求参数有误
- 401 未认证，请求要求用户的身份认证，如token不存在就会报错。
- 403 服务器理解请求客户端的请求，但是拒绝执行此请求。如没有权限就会报错。
- 404 请求的资源（网页等）不存在。不能确定资源是永远或临时的丢失。
- 410 说明请求的内容在服务器上永久丢失了
- 422 语义错误
- 500 服务器错误
- 504 服务器超时
### 301和302的区别

#### 1. 定义

`301`：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 `URI` 之一。客户端会把请求的地址修改为从服务器反馈回来的地址。

`302`：请求的资源现在临时从不同的 `URI` 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。

两者都是一个POST请求经过 `301/302` 后会被浏览器转为`GET`请求

#### 2. 缓存

对于`301`请求，浏览器是默认可缓存。

而`302`，只有在`Cache-Control`或`Expires`中进行了指定的情况下，这个响应才是可缓存的。

#### 3. 搜索引擎

`301`: 旧地址A的资源不可访问了(永久移除), 重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。

`302`: 旧地址A的资源仍可访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取B网址内容，但是会将网址保存为A的。

#### 4. 安全

尽量使用301跳转，以防止网址劫持！

大部分搜索引擎在收到302 重定向时，不能总是抓取目标网址。

比如说，A -> B，有的时候A 网址很短，而B 网址是一个很长的乱七八糟的URL 网址，A 网址更加用户友好。这时搜索引擎很有可能会仍然显示网址A。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。

## `HTTP1.0 HTTP 1.1`主要区别
[HTTP1.0 HTTP 1.1 HTTP 2.0主要区](https://blog.csdn.net/linsongbin1/article/details/54980801)
[如何优雅的谈论HTTP／1.0／1.1／2.0]([https://www.jianshu.com/p/52d86558ca57)
- 长连接
  默认把`connection`设置为`keep-alive`，支持长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少`TCP`三次握手四次挥手的消耗和延迟，但是同一时刻只能有一个`http`请求
  HTTP 1.0默认短连接，需要使用keep-alive参数来告知服务器端要建立一个长连接
- 只发首部，节约带宽
  HTTP 1.1**支持**只发送请求头，如果**服务器认为客户端有权限请求服务器，则返回100，否则返回401**。客户端如果接受到100，才可以开始把请求体发送到服务器。
  另外HTTP还支持传送内容的一部分。这样当**客户端已经有一部分的资源**后，只需要**跟服务器请求另外的部分资源**即可。这是支持文件**断点续传的基础**。
- host
  `HTTP1.0`是没有host域的，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个`IP`地址和端口号上配置多个虚拟WEB站点。`HTTP1.1`才支持这个参数。

## `HTTP1.1` `HTTP 2.0`主要区别

- 多路复用
  **同域名下**的所有通信都在**同一个`TCP`连接**上并行完成，互不干扰。消除了因多个 TCP 连接而带来的延时和内存消耗。对端可以通过帧中的标识知道属于哪个请求。
- 首部压缩
  `HTTP2.0`使用`HPACK`算法对`header`的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
- 服务端推送
  服务器可以对客户端的**一个请求发送多个响应**。如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的**优势**：可以缓存！同源页面之间可以共享缓存资源。
- 二进制传输
  HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。改进传输性能，实现低延迟和高吞吐量。之前数据只能通过文本形式传输，现在可以把数据进行分割，用二进制进行编码。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190910222230867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbmx1YmFiYTY2Ng==,size_16,color_FFFFFF,t_70)
#### HTTP 协议的特点

- 无连接
  - 限制每次连接只处理一个请求
- 无状态
  - 协议对于事务处理没有记忆能力。
- 简单快速
  - 客户向服务器请求服务时，只需传送请求方法和路径。
- 灵活
  - HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

### `http`和`https`

<https://segmentfault.com/a/1190000012196642>

`https`不是一种新的协议，而是`http`+`ssl`或者`http`+`tls`。`http`用的是明文传输，这样它传输的数据就十分的不安全，于是就有了`ssl`，用于对`http`协议传输的数据进行加密。

可是加密过程中存在一些问题

- 浏览器和服务器都使用共享密钥进行加密，如果共享密钥被窃取，那么加密就会失去意义。如何防止共享密钥不被窃取呢？
- 非对称加密，浏览器生成共享密钥，浏览器用服务器的公钥加密信息，服务器用私钥解密，这样就可以获取到共享密钥，再用共享密钥对信息进行加密。可是如何保证服务器的公钥没有被攻击者替换掉呢？
- 可以使用CA机构颁布的公开密钥证书。

所以过程为

- 浏览器给服务器发支持的加密规则

- 服务器从客户端发送来的加密规则中选取一种。
- 接着服务器把公开密钥发送给`CA`机构，`CA`机构会颁布一个证书。`CA`证书里包含了服务器私钥，签发者，证书用途，证书到期时间，使用的`HASH`算法，签名使用的算法等。接着会把证书内容求一个`HASH`值，再用`CA`私钥把证书内容的`HASH`及其使用的`HASH`算法进行加密，完成数字签名，服务器会把`CA`证书发给浏览器。

- 客户端拿到服务器的公钥证书之后，先验证证书的合法性。

  - 校验证书中包含的域名是否和正在访问的网站一致，证书是否过期
  - 把操作系统内置`CA`和证书颁发者`CA`进行比对，验证合法性

  - 客户端先用`CA`公钥对数字签名进行解密，取出`hash`算法。(数字签名包括`hash`算法和`CA`证书内容的`hash`），接着再用`hash`算法对`CA`证书的内容求值，校验加密后的内容和数字签名内的`hash`内容是否一致，如果一致的话，那么可以取出服务器的公钥。

- 接着，客户端就会生成共享密钥，用服务器的公钥进行加密，发送给服务器。

- 服务器用私钥把客户端发送的信息进行解密

- 之后服务器和浏览器发送信息时都用共享密钥进行加密。如果在握手过程中出现任何错误，都会使加密连接断开。

[https为什么需要证书](https://aadonkeyz.com/posts/c9a2a716/?from=from_parent_mindnote)



