[面试精选之http缓存(轻松易读梳理)](https://juejin.im/post/5b3c87386fb9a04f9a5cb037)

# Expries

`Expires`响应头是HTTP 1.0的一部分，它允许服务器指定资源的过期时间和日期。例如

```
Expires: Wed, 21 Oct 2015 07:28:00 GMT
```

客户端通过HTML `<meta>` 标签模拟。如下

```html
//也可以设置在在html文件头中
<meta http-equiv="expires" content="Thu, 30 Nov 2017 11:17:26 GMT">
```

HTML中 `<meta http-equiv="...">`的缓存控制能力受限，并且不是所有浏览器都会完全遵守这些指令。

如果在 `Cache-Control`响应头设置了 `max-age`或者 `s-max-age`指令，那么 `Expires` 头会被忽略。

# Cache-control

## 语法

**`Cache-Control`在请求头中**

在请求头中，客户端可以使用 `Cache-Control`来表达自己关于响应的缓存预期。请求头中的 `Cache-Control`可以包含如下指令：

* `no-cache`：走协商缓存。协商缓存和强缓存在网络安全的另外一篇。
* `no-store`：禁止缓存。
* `max-age=<seconds>`：表示客户端愿意接受一个存储时间不超过指定秒数的响应。
* `min-fresh=<seconds>`：表示客户端希望在指定的秒数内获取一个最新的响应。

  * 请求头的 `min-fresh`和服务端的 `max-age`配合使用。
  * `max-age`（在响应头中）告诉客户端和中介缓存该资源在多长时间内被认为是新鲜的，而 `min-fresh`（在请求头中）则告诉缓存，客户端希望接受的响应在请求发出后至少还保持新鲜的时间。
* `max-stale=<seconds>`：这里 `<seconds>`是客户端指明愿意接受的过期时间上限。* 举个例子，`max-stale=60`表示客户端愿意接受最多在60秒前过期的资源。在没有指定值的情况下，客户端表示它愿意接受任何年龄的过期响应。
* `no-transform`：不允许代理服务器对资源进行转换。

  * `Content-Encoding`、`Content-Range`、`Content-Type`等HTTP头不能由代理修改。例如，非透明代理可能对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。`no-transform`指令不允许这样做。
* `only-if-cached`：请求只需要返回已经被缓存的响应，如果没有缓存可用，中间缓存应该返回一个HTTP 504 Gateway Timeout状态码，而非真正向源服务器去请求。

  * 在没有其他指令优先级覆盖的情况下，`must-revalidate` 指令会覆盖 `max-stale` 的行为。这样做的目的是为了保证客户端获取的数据的正确性和新鲜度

**`Cache-Control`在响应头中**

正如您所描述的，`Cache-Control`在响应头中指示了如何缓存某个资源，和资源缓存的有效性：

* `private`：指示响应是针对单个用户的，一般由浏览器缓存。不应该由共享缓存存储（如代理服务器）。
* `public`：表明任何代理服务器或其他类型的缓存服务器都可以缓存该响应。
* `no-cache`：协商缓存。
* `no-store`：禁止缓存。
* `max-age=<seconds>`：指示资源保持新鲜的最大时间；这个时间是相对于响应发出的时间。
* `s-maxage=<seconds>`

  * **用途** ：覆盖 `max-age`，但是仅适用于共享缓存（如代理服务器），私有缓存会忽略它。
  * **场景** ：缓存策略控制。
    * 例子，一个响应可以对用户浏览器有更长时间的本地缓存（使用 `max-age`），但对代理服务器上的缓存时间较短（使用 `s-maxage`），从而确保代理服务器中的内容是比较新鲜的。
* `no-transform` 指令告诉中间缓存（比如代理服务器）不得更改响应体的内容，包括内容编码改变（比如gzip压缩）和媒体类型转换（比如将图片从 `image/png`转换为 `image/webp`）。

  * **场景** ：当内容的具体表示对客户端非常重要时，这个指令特别有用。例如，一个为视觉受损用户而设计的图片 content delivery network (CDN) 可能会想要确保图片不会被转换，因为这些转换可能会移除图片中的重要对比度或者信息。
* `must-revalidate`：告诉缓存，一旦资源过期（例如 `max-age`），在使用之前必须重新验证有效性。

  * 在没有其他指令优先级覆盖的情况下，`must-revalidate` 指令会覆盖 `max-stale` 的行为。这样做的目的是为了保证客户端获取的数据的正确性和新鲜度
* `proxy-revalidate`

  * **用途** ：与 `must-revalidate` 类似，指示共享缓存（比如代理服务器）在服务缓存的响应给后续请求之前，必须验证其有效性。但它不适用于私有缓存。
  * **场景** ：控制共享缓存，确保用户不会接收到过期的内容，同时又无需每个用户的缓存都对服务器验证，减少了服务器的负担。
* `stale-while-revalidate=<seconds>`

  * 在 `seconds`期间，缓存应异步地重新验证资源的新鲜度或更新资源内容，但用户依然可以获得即时的响应，因为他们获得的是缓存的版本。
* `stale-if-error=<seconds>`

  * 表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。
* `immutable`

  * 表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头（例如 `If-None-Match`或I `f-Modified-Since`）来检查更新，即使用户显式地刷新页面。

## 优先级

响应头的指令对资源的控制权高于请求头。特别是在决定如何处理缓存和资源有效性验证时。

在某些情况下也有例外，比如 `Accept-Encoding` 请求头告诉服务器客户端能够理解的内容编码形式（如gzip），服务器通常会尊重这一请求来优化响应数据的传输。

## QA

**共享缓存和私有缓存的区别**

- `public` 缓存（共享缓存）

当一个HTTP响应被标记为 `public`，意味着响应是可以被多个用户共享的。这通常适用于那些不包含用户专属数据的资源。`public` 缓存适用的情况包括但不限于：

* **静态资源** ：网站的公共资源，如CSS样式表、JavaScript脚本、图片、字体文件等，这些文件通常在不同用户之间是相同的，并且不含有敏感或个人信息。
* **下载文件** ：如PDF文档、软件安装包等，如果这些资源是对所有用户开放的，则可以设置为 `public`，由缓存来减少服务器重复发送相同数据的负担。
* **公开内容页** ：如新闻文章、博客帖子等不需要用户登录即可查看的网页，可以通过 `public` 缓存建立共享缓存，加快内容分发。

例如，一个网站的logo图片通常对所有用户是相同的，因此HTTP响应可以包含如下头：

```
Cache-Control: public, max-age=86400
```

这表明logo图片可以被缓存，并且在86400秒（一天）内是新鲜的，且可以在如公司的代理服务器或互联网服务提供商（ISP）的缓存服务器中被保存和共享给所有请求这个资源的用户，而不需要每个用户都从源服务器加载它。

- `private` 缓存（私有缓存）

当一个HTTP响应被标记为 `private`，意味着响应只能由一个特定用户使用，不能在多用户间共享。这类资源通常含有用户专属或敏感信息。`private` 缓存适用的情况包括但不限于：

* **个性化内容** ：例如个人资料页面、电子邮件清单、定制首页等。
* **用户特定的数据** ：如购物车信息、搜索历史、用户设置等。

例如，用户登录到社交网络后请求的首页就可能包含用户特定的数据，服务器返回的响应头可能包括：

```
Cache-Control: private, max-age=300
```

# 协商缓存部分（缓存验证）

## HTTP1.0

### Last-Modified

响应头，包含**资源修改的时间**。 浏览器会缓存这个资源及其最后修改时间，并被用来和上一次的修改时间比较是否一致。只能精确到秒，精确度比 `ETag`要低。包含有 `If-Modified-Since`或 `If-Unmodified-Since`首部的条件请求会使用这个字段。

### If-Modified-Since

请求头，等于上一次请求的Last-Modified。服务器比较请求头里的 If-Modified-Since 时间和服务器上 a.js的上次修改时间：

对于 `GET`和 `HEAD`请求方法来说

- 如果一致，返回一个不带有消息主体的 `304` 响应。浏览器收到后使用本地缓存。
- 如果不一致，返回一个带有最近修改时间 `Last-Modified`以及过期时间 `Expries`以及消息主体的 `200`响应。
- 当与 `If-None-Match`一同出现时，会被覆盖，除非服务器不支持 `If-None-Match`。

对于其他方法，HTTP没有定义其表现，一般会被服务器忽略。

### if-Unmodified-Since

请求头，它的用法和 `If-Modified-Since` 相反。客户端通过这个头告诉服务器，只有当请求的资源自给定日期以来没有被修改时，请求才会成功。

- 如果资源在 `If-Unmodified-Since` 头部指定的时间之后被修改过，服务器会返回一个 `412 Precondition Failed` 状态码。这主要用来防治空中碰撞，下面会说。

缺点：

- 精度精确到秒：浏览器给资源设置无缓存，资源在一秒内修改，浏览器拿不到最新资源。
- 资源变更检查机制：资源打开并保存，但没有修改也会更新 `last-modified`的时间，服务器会因为时间匹配不上重新返回资源主体。

为了增加文件内容对比，引入了 `Etag`

## HTTP1.1

### Etag

`Etag`响应头，由服务器为特定的资源版本生成。它是一个标识符，通常是资源内容的哈希值或其它某种形式的指纹。资源内容不改变，`Etag`不变。

`ETag`有两种变体：强 `ETag`和弱 `ETag`。

#### 强ETag

强 `ETag`表示资源的字节级精确表示。当一个资源的 `ETag`是强标签时，即使是资源的微小更改，也会导致 `ETag`的变化。

**示例：**

文件1（版本A）内容："Hello, World!" —— 强ETag："1edec-3e3073913b780"

文件1（版本B）内容稍微改变："Hello, World?" —— 强ETag："1edec-2a3073913b780"

即使只有一个字符的更改，强ETag也会完全不同，服务器会认为这是一个完全不同的资源版本。

**使用场景：**

大多数情况，因为它们为资源提供了更严格的唯一标识符。

#### 弱ETag

弱ETag更加宽容，它通常只保证语义相同的变动不会触发ETag的改变，允许一些无关紧要的变动发生而不改变ETag。

弱 `ETag`在值前会有一个 `W/`前缀，表示是弱标签。

* 文件2（版本A）内容：—— 弱ETag：W/"12345-678"

  ```html
  <html>
    <head>
      <title>My Page</title>
    </head>
    <body>
      <p>Welcome to my page.</p>
    </body>
  </html>
  ```
* 文件2（版本B）内容在格式上有些调整，但实质未变：—— 弱ETag：W/"12345-678"

  ```html
  <html>
    <head><title>My Page</title></head>
    <body><p>Welcome to my page.</p></body>
  </html>
  ```

在这种情况下，由于输出内容（即渲染在浏览器中的结果）没有实质性改变，服务器可以决定继续使用相同的弱ETag，表示资源语义上没有变化。弱ETag主要用于性能优化，当不需要字节级精确匹配的内容时，它可以减轻服务器压力，并减少不必要的数据传输。

### If-none-match

请求头。值为上次请求同一资源时，服务器返回给浏览器的Etag，可以有多个Etag值。（这个在下面QA中解释）

对于 `GET`和 `HEAD`请求方法来说

- 当不匹配时，服务器端会返回所请求的资源，响应码为 `200`。当匹配时，服务器端必须返回响应码 304（未改变）。
- 304 的响应 和  200 响应中的共有首部 ：`Cache-Control`、 `Expires`、`ETag`。
- 当与 `If-Modified-Since`一同使用的时候，`If-None-Match`优先级更高。

对于除 `GET` 和 `HEAD` 之外的其他HTTP请求方法（如 `POST`、`PUT`、`DELETE`、`PATCH` 等）：

- 这通常用于创建操作，避免创建重复资源。
- 通常使用 `If-None-Match:*` 创建新资源。设置 `If-None-Match: *`表示仅当服务器上没有任何版本的资源时才执行创建操作。
- 如果不匹配，会返回 `201 Created`，响应可能会包括 `Location` 头部，指示新创建资源的UR。
- 如果 `If-None-Match` 的任何一个值与服务器的 `ETag` 相匹配，返回状态码 `412`

#### QA

**为什么Etag有多个值**

大多数情况， `If-None-Match` 请求头通常只包含一个ETag值。

- 多个版本的资源

这可以是因为客户端以不同方式请求同一资源（例如，不同的压缩或语言版本），或者资源多次更新，而客户端缓存了多个过时的版本。

- 负载平衡和数据中心复制

在分布式系统或使用CDN的情况下，同一资源可能有不同的ETag值，这取决于请求是发送到哪个服务节点或数据中心。客户端可能从多个位置获取资源副本，并希望确保其中的任何一个仍然有效。

- 客户端合并请求

某些客户端可能会试图在一个请求中校验多个资源，以减少网络往返次数。

- 客户端代理和同步工具

代理服务器或内容同步工具可能会代表多个客户端进行资源检索，同时持有不同ETag版本。

### If-match

对于 `GET`和 `HEAD`请求方法来说， `If-Match` 请求头的使用不多见，情况如下。

* 如果提供的 ETag 与资源当前的 ETag 匹配，服务器会正常返回资源，并且响应通常是 `200 OK` 状态（对于 `GET` 请求）或 `304 Not Modified` 状态（如果还有 `If-None-Match` 首部且条件满足）。
* 如果 ETag 不匹配，意味着自从客户端上次获取资源以来资源已被修改，服务器会返回 `412`状态码，拒绝响应这个请求。这确保了客户端不会基于过时的资源信息进行读取操作。

对于诸如 `PUT`、`DELETE` 以及其他可能修改资源状态的HTTP方法，`If-Match` 的作用就变得非常关键了。这里是它的行为：

- 通常用于编辑更新情况，保证更新是基于服务端的最新版本
- 如果匹配，会返回 `200`或 `204 No Content` 状态码来表明请求已成功处理。
- 如果 ETag 不匹配，服务器会返回 `412`状态码

## 比较

### If-Modified-Since和If-None-Match的同与异

#### 同：

1. **缓存验证** ：对于 `GET` 和 `HEAD` 请求, 它们都用于缓存验证，资源未被修改返回304，被修改返回200

#### 异：

1. **基于时间 vs. 基于版本** ：`If-Modified-Since` 基于资源的最后修改时间（精确到秒）。`If-None-Match` 的ETag通常是基于资源内容生成的哈希值，能够更细粒度地标识资源的变更，特别适用于资源频繁更新的情形。
2. **值的复杂性** ：`If-Modified-Since` 只能包含一个时间值，而 `If-None-Match` 可以包含多个ETag值。
3. **对其他请求的影响** ：`If-Modified-Since` 通常不用于其他请求。而 `If-None-Match` 在结合诸如 `PUT` 或 `DELETE` 这样的方法时非常有用，有相同的值会412，能够防止“空中碰撞”，即确保客户端只有在拥有最新版本的资源时才可以操作。
4. **优先级问题** ：`If-None-Match` 优先级高

### 补充：

5. **弱验证器与强验证器** ：`If-None-Match` 使用的ETag可以区分为“强验证器”和“弱验证器”。强ETag严格表示资源的每个字节都未发生变化，而弱ETag允许服务端对资源做一些不影响内容含义的改变（如格式化变化）。
