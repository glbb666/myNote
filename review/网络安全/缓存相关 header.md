### 缓存相关 header

#### Pragma

是HTTP/1.0标准中定义的一个header属性，效果依赖于不同的实现，所以在请求-响应链中会有不同的效果，它用来向后兼容只支持HTTP/1.0协议的缓存服务器。

```
pragma: no-cache
```

与`Cache-control：no-cache `一致，强制要求缓存服务器在使用缓存时先将请求提交到源服务器进行验证

#### Expries

响应头包含日期/时间， 即在此时候之后，响应过期。

无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。

如果在`Cache-Control`响应头设置了`max-age`或者`s-max-age`指令，那么 `Expires` 头会被忽略。

```
//也可以在html头部
<meta http-equiv="expires" content="Thu, 30 Nov 2017 11:17:26 GMT">
```

#### Cache-control

##### 请求指令

- **max-age=<seconds>**： 设置缓存存储的最大周期，超过这个时间缓存被认为过期（秒），与Expires相反，时间是相对于请求的时间。

  某些浏览器（比如Firefox）中如果设定为永不缓存，那么其发出的请求中，请求头会包含`max-age=0`。

- **max-stale=<seconds>**： 客户端愿意接受一个过期的资源，可选的设置一个时间（单位秒），表示响应不能超过的过时时间。

- **min-fresh=<seconds>**： 客户端在指定的时间内获取最新的响应

- **no-cache**

- **no-store**

- **no-transform**

- **Only-if-cahced**：客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝，cache要么用缓存的内容给出响应，要么给出一个504（GateWay Timeout）响应码。如果一组cache被作为一个内部相连的系统，那么其中的某个成员可以向这个缓存组里请求响应。

##### 响应指令

- **must-revalidate**： 缓存必须在使用前验证旧资源的状态，并且不可使用过期资源
- **no-cache**： 在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证
- **no-store**：缓存不应存储有关客户端请求或服务器响应的任何内容。
- **no-transform**：不得对资源进行转换或转变。`Content-Encoding`, `Content-Range`, `Content-Type`等HTTP头不能由代理修改。例如，非透明代理可以对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。 `no-transform`指令不允许这样做。
- **Public**: 响应可以被任何对象（发送请求的客户端，代理服务器等）缓存
- **private**：响应只能被单个用户缓存，不能作为共享缓存（代理服务器不能缓存它），可以缓存响应内容
- **max-age=<seconds>**： 设置缓存存储的最大周期，超过这个时间缓存被认为过期（秒），与Expires相反，时间是相对于请求的时间。
- **proxy-revalidate**： 与`must-revalidate`作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。
- **s-maxage=<seconds>**：覆盖`max-age`或者`Expries`头。但是仅用于共享缓存（比如各个代理），私有缓存会被忽略

##### 拓展指令

- **immutable**：表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头（例如`If-None-Match`或`If-Modified-Since`）来检查更新，即使用户显式地刷新页面。
- **stale-while-revalidate=<seconds>**：客户端愿意接受陈旧的响应，同时在后台异步检查新的响应，秒值表示客户端愿意接受陈旧响应的时间
- **stale-if-error=<seconds>**: 表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。

#### If-Modified-Since(HTTP/1.0) / Last-Modified(HTTP/1.0) /If-Unmodified-Since

##### Last-Modified

响应首部，包含源服务器认定的资源修改的日期及时间。 通常被用作一个验证器来判断接收到的和存储的资源是否彼此一致。由于精确度比`ETag`要低，经常作为一个备用机制。包含有`If-Modified-Since`或`If-Unmodified-Since`首部的条件请求会使用这个字段。

##### If-Modified-Since

条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为`200` 。否则返回一个不带有消息主体的`304` 响应，在`Last-Modified`首部中带有上次修改时间。 不同于`If-Unmodified-Since`, `If-Modified-Since` 只可以用在`GET`或`HEAD`请求中。

当与`If-None-Match`一同出现时，会被忽略掉，除非服务器不支持 `If-None-Match`。

最常见的应用场景是来更新没有特定`ETag`标签的缓存实体。

##### If-Unmodified-since

请求首部，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源。或是接受`POST`或其他`non-safe`方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回`412`(Precondition Failed/先决条件失败）错误。

常见的应用场景有两种：

- 与`non-safe`方法如`POST`搭配使用，可以用来优化并发控制，例如在某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其作出的编辑会被拒绝提交。
- 与含有`If-Range`消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。

###### Notes

- 本地打开缓存文件但是没有修改也会更新`last-modified`的时间
- `last-modified`以秒计时，在一秒内做了更改`last-modified`不会做出更新

#### If-Match/If-None-Match/ETag

##### If-Match

请求首部。在请求方法为`GET`和`HEAD`的情况下，服务器仅在请求的资源满足此首部列出的 `ETag `之一时才会返回资源。而对于`PUT`或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。

`ETag`存储比较使用的是**强比较算法**，即只有在每一个比特都相同的情况下，才认为两个文件是相同的。采用相对宽松的算法可以在`ETag`前面添加`W/`。

###### 两个常见的应用场景：

- 对于`GET`和`HEAD`方法，搭配`Range`首部使用，可以用来保证新请求的范围与之前请求的范围是对同一份资源的请求。如果 ETag 无法匹配，那么需要返回`416` (Not Satisfiable，范围请求无法满足) 响应。
- 对于其他方法来说，尤其是`PUT`, `If-Match` 首部可以用来避免更新丢失问题。它可以用来检测用户想要上传的不会覆盖获取原始资源之后做出的更新。如果请求的条件不满足，那么需要返回 `412`(Precondition Failed，先决条件失败) 响应。

##### If-None-Match / Etag(http1.1)

请求首部。对于`GET`和`HEAD`请求方法来说，当且仅当服务器上没有任何资源的`ETag`属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为`200` 。对于其他方法来说，当且仅当最终确认没有已存在的资源的`ETag`属性值与这个首部中所列出的相匹配的时候，才会对请求进行相应的处理。

对于`GET`和`HEAD`方法来说，当验证失败的时候，服务器端必须返回响应码 304（Not Modified，未改变）。对于能够引发服务器状态改变的方法，则返回 412 （Precondition Failed，前置条件失败）。

###### Notes

服务器端在生成状态码为 304 的响应的时候，必须同时生成以下会存在于对应的 200 响应中的首部：`Cache-Control`、`Content-Location`、`Date`、`ETag`、`Expires` 和 `Vary`。

`ETag`属性之间的比较采用的是**弱比较算法**，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的。例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的。

当与`If-Modified-Since`一同使用的时候，`If-None-Match`优先级更高（假如服务器支持的话）。

以下是两个常见的应用场景：

- 采用`GET`或`HEAD`方法，来更新拥有特定的`ETag`属性值的缓存。
- 采用其他方法，尤其是`PUT`,将 `If-None-Match` used 的值设置为 * ，用来生成事先并不知道是否存在的文件，可以确保先前并没有进行过类似的上传操作，防止之前操作数据的丢失。这个问题属于更新丢失问题的一种。

##### ETag

HTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。

**语法**

```
ETag: W/"<etag_value>"
ETag: "<etag_value>"
```

**指令**

- `W/` 可选

  `'W/'`(大小写敏感) 表示使用弱验证器。 弱验证器很容易生成，但不利于比较。 强验证器是比较的理想选择，但很难有效地生成。 相同资源的两个弱`Etag`值可能语义等同，但不是每个字节都相同。

- "<etag_value>"

  实体标签唯一地表示所请求的资源。 它们是位于双引号之间的ASCII字符串（如“675af34563dc-tr34”）。 没有明确指定生成ETag值的方法。 通常，使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号。 例如，MDN使用wiki内容的十六进制数字的哈希值。

\###缓存机制

#### 新鲜度

理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的*。*驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了`304` (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过`If-None-Match`或`If-Modified-Since`判断后发现已过期，那么会带有该资源的实体内容返回。

**图示**

[![img](https://github.com/nvnvyezi/Daily-notes/raw/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/http%E7%BC%93%E5%AD%98.assets/HTTPStaleness.png)](https://github.com/nvnvyezi/Daily-notes/blob/master/网络基础/http缓存.assets/HTTPStaleness.png)

对于含有特定头信息的请求，会去计算缓存寿命。比如`Cache-control: max-age=N`的头，相应的缓存的寿命就是`N`。通常情况下，对于不含这个属性的请求则会去查看是否包含`Expires`属性，通过比较`Expires`的值和头里面`Date`属性的值来判断是否缓存还有效。如果`max-age`和`expires`属性都没有，可以去找响应头里的`Last-Modified`信息。如果有，缓存的寿命就等于头里面`Date`的值减去`Last-Modified`的值除以10（注：根据rfc2626其实也就是乘以10%）

缓存失效时间计算公式如下：

```
expirationTime = responseTime + freshnessLifetime - currentAge
```

`responseTime` 表示浏览器接收到此响应的那个时间点