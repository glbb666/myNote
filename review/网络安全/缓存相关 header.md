[面试精选之http缓存(轻松易读梳理)](https://juejin.im/post/5b3c87386fb9a04f9a5cb037)

# Expries

`Expires`响应头是HTTP 1.0的一部分，它允许服务器指定资源的过期时间和日期。例如

```
Expires: Wed, 21 Oct 2015 07:28:00 GMT
```

如果在 `Cache-Control`响应头设置了 `max-age`或者 `s-max-age`指令，那么 `Expires` 头会被忽略。

# Cache-control

## 语法

**`Cache-Control`在请求头中**

在请求头中，客户端可以使用 `Cache-Control`来表达自己关于响应的缓存预期。请求头中的 `Cache-Control`可以包含如下指令：

* `no-cache`：走协商缓存。协商缓存和强缓存在网络安全的另外一篇。
* `no-store`：禁止缓存。
* `max-age=<seconds>`：表示客户端愿意接受一个存储时间不超过指定秒数的响应。
* `min-fresh=<seconds>`：表示客户端希望在指定的秒数内获取一个最新的响应。

  * 请求头的 `min-fresh`和服务端的 `max-age`配合使用。
  * `max-age`（在响应头中）告诉客户端和中介缓存该资源在多长时间内被认为是新鲜的，而 `min-fresh`（在请求头中）则告诉缓存，客户端希望接受的响应在请求发出后至少还保持新鲜的时间。
* `max-stale=<seconds>`：这里 `<seconds>`是客户端指明愿意接受的过期时间上限。* 举个例子，`max-stale=60`表示客户端愿意接受最多在60秒前过期的资源。在没有指定值的情况下，客户端表示它愿意接受任何年龄的过期响应。
* `no-transform`：不允许代理服务器对资源进行转换。

  * `Content-Encoding`、`Content-Range`、`Content-Type`等HTTP头不能由代理修改。例如，非透明代理可能对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。`no-transform`指令不允许这样做。
* `only-if-cached`：请求只需要返回已经被缓存的响应，如果没有缓存可用，中间缓存应该返回一个HTTP 504 Gateway Timeout状态码，而非真正向源服务器去请求。

  * 在没有其他指令优先级覆盖的情况下，`must-revalidate` 指令会覆盖 `max-stale` 的行为。这样做的目的是为了保证客户端获取的数据的正确性和新鲜度

**`Cache-Control`在响应头中**

正如您所描述的，`Cache-Control`在响应头中指示了如何缓存某个资源，和资源缓存的有效性：

* `private`：指示响应是针对单个用户的，一般由浏览器缓存。不应该由共享缓存存储（如代理服务器）。
* `public`：表明任何代理服务器或其他类型的缓存服务器都可以缓存该响应。
* `no-cache`：协商缓存。
* `no-store`：禁止缓存。
* `max-age=<seconds>`：指示资源保持新鲜的最大时间；这个时间是相对于响应发出的时间。
* `s-maxage=<seconds>`

  * **用途** ：覆盖 `max-age`，但是仅适用于共享缓存（如代理服务器），私有缓存会忽略它。
  * **场景** ：缓存策略控制。
    * 例子，一个响应可以对用户浏览器有更长时间的本地缓存（使用 `max-age`），但对代理服务器上的缓存时间较短（使用 `s-maxage`），从而确保代理服务器中的内容是比较新鲜的。
* `no-transform` 指令告诉中间缓存（比如代理服务器）不得更改响应体的内容，包括内容编码改变（比如gzip压缩）和媒体类型转换（比如将图片从 `image/png`转换为 `image/webp`）。

  * **场景** ：当内容的具体表示对客户端非常重要时，这个指令特别有用。例如，一个为视觉受损用户而设计的图片 content delivery network (CDN) 可能会想要确保图片不会被转换，因为这些转换可能会移除图片中的重要对比度或者信息。
* `must-revalidate`：告诉缓存，一旦资源过期（例如 `max-age`），在使用之前必须重新验证有效性。

  * 在没有其他指令优先级覆盖的情况下，`must-revalidate` 指令会覆盖 `max-stale` 的行为。这样做的目的是为了保证客户端获取的数据的正确性和新鲜度
* `proxy-revalidate`

  * **用途** ：与 `must-revalidate` 类似，指示共享缓存（比如代理服务器）在服务缓存的响应给后续请求之前，必须验证其有效性。但它不适用于私有缓存。
  * **场景** ：控制共享缓存，确保用户不会接收到过期的内容，同时又无需每个用户的缓存都对服务器验证，减少了服务器的负担。
* `stale-while-revalidate=<seconds>`

  * 在 `seconds`期间，缓存应异步地重新验证资源的新鲜度或更新资源内容，但用户依然可以获得即时的响应，因为他们获得的是缓存的版本。
* `stale-if-error=<seconds>`

  * 表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。
* `immutable`

  * 表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头（例如 `If-None-Match`或I `f-Modified-Since`）来检查更新，即使用户显式地刷新页面。

## 优先级

响应头的指令对资源的控制权高于请求头。特别是在决定如何处理缓存和资源有效性验证时。

在某些情况下也有例外，比如 `Accept-Encoding` 请求头告诉服务器客户端能够理解的内容编码形式（如gzip），服务器通常会尊重这一请求来优化响应数据的传输。

## QA

**共享缓存和私有缓存的区别**

- `public` 缓存（共享缓存）

当一个HTTP响应被标记为 `public`，意味着响应是可以被多个用户共享的。这通常适用于那些不包含用户专属数据的资源。`public` 缓存适用的情况包括但不限于：

* **静态资源** ：网站的公共资源，如CSS样式表、JavaScript脚本、图片、字体文件等，这些文件通常在不同用户之间是相同的，并且不含有敏感或个人信息。
* **下载文件** ：如PDF文档、软件安装包等，如果这些资源是对所有用户开放的，则可以设置为 `public`，由缓存来减少服务器重复发送相同数据的负担。
* **公开内容页** ：如新闻文章、博客帖子等不需要用户登录即可查看的网页，可以通过 `public` 缓存建立共享缓存，加快内容分发。

例如，一个网站的logo图片通常对所有用户是相同的，因此HTTP响应可以包含如下头：

```
Cache-Control: public, max-age=86400
```

这表明logo图片可以被缓存，并且在86400秒（一天）内是新鲜的，且可以在如公司的代理服务器或互联网服务提供商（ISP）的缓存服务器中被保存和共享给所有请求这个资源的用户，而不需要每个用户都从源服务器加载它。

- `private` 缓存（私有缓存）

当一个HTTP响应被标记为 `private`，意味着响应只能由一个特定用户使用，不能在多用户间共享。这类资源通常含有用户专属或敏感信息。`private` 缓存适用的情况包括但不限于：

* **个性化内容** ：例如个人资料页面、电子邮件清单、定制首页等。
* **用户特定的数据** ：如购物车信息、搜索历史、用户设置等。

例如，用户登录到社交网络后请求的首页就可能包含用户特定的数据，服务器返回的响应头可能包括：

```
Cache-Control: private, max-age=300
```

# 协商缓存部分（缓存验证）

## HTTP1.0和HTTP1.1响应头

### Last-Modified

响应头，包含**资源修改的时间**。 浏览器会缓存这个资源及其最后修改时间，并被用来和上一次的修改时间比较是否一致。只能精确到秒，精确度比 `ETag`要低。包含有 `If-Modified-Since`或 `If-Unmodified-Since`首部的条件请求会使用这个字段。

### Etag

`Etag`响应头，由服务器为特定的资源版本生成。它是一个标识符，通常是资源内容的哈希值或其它某种形式的指纹。资源内容不改变，`Etag`不变。

`ETag`有两种变体：强 `ETag`和弱 `ETag`。

#### 强ETag

强 `ETag`表示资源的字节级精确表示。当一个资源的 `ETag`是强标签时，即使是资源的微小更改，也会导致 `ETag`的变化。

**示例：**

文件1（版本A）内容："Hello, World!" —— 强ETag："1edec-3e3073913b780"

文件1（版本B）内容稍微改变："Hello, World?" —— 强ETag："1edec-2a3073913b780"

即使只有一个字符的更改，强ETag也会完全不同，服务器会认为这是一个完全不同的资源版本。

**使用场景：**

大多数情况，因为它们为资源提供了更严格的唯一标识符。

#### 弱ETag

弱ETag更加宽容，它通常只保证语义相同的变动不会触发ETag的改变，允许一些无关紧要的变动发生而不改变ETag。

弱 `ETag`在值前会有一个 `W/`前缀，表示是弱标签。

* 文件2（版本A）内容：—— 弱ETag：W/"12345-678"

  ```html
  <html>
    <head>
      <title>My Page</title>
    </head>
    <body>
      <p>Welcome to my page.</p>
    </body>
  </html>
  ```
* 文件2（版本B）内容在格式上有些调整，但实质未变：—— 弱ETag：W/"12345-678"

  ```html
  <html>
    <head><title>My Page</title></head>
    <body><p>Welcome to my page.</p></body>
  </html>
  ```

在这种情况下，由于输出内容（即渲染在浏览器中的结果）没有实质性改变，服务器可以决定继续使用相同的弱ETag，表示资源语义上没有变化。弱ETag主要用于性能优化，当不需要字节级精确匹配的内容时，它可以减轻服务器压力，并减少不必要的数据传输。

## HTTP1.0和HTTP1.1请求头

### If-Modified-Since和If-None-Match

#### 不同点

- If-Modified-Since：是基于时间的条件请求头，服务器比较请求头里的 `If-Modified-Since` 时间和服务器上资源的上次修改时间。
- If-None-Match：基于内容的条件请求头，浏览器会在请求头中包含资源的ETag，可以有多个ETag值。
- If-Modified-Since：对于非GET和HEAD请求，HTTP没有定义其表现，一般会被服务器忽略。
- If-None-Match：对于非GET和HEAD请求
  * 通常使用 `If-None-Match:*` 创建新资源。设置 `If-None-Match: *` 表示仅当服务器上没有任何版本的资源时才执行创建操作。
  * 如果不匹配，会返回 `201 Created`，响应可能会包括 `Location` 头部，指示新创建资源的URI。
  * 如果 `If-None-Match` 的任何一个值与服务器的 `ETag` 相匹配，返回状态码 `412 Precondition Failed`。

#### 相同点

- 常见请求：get和head。如果一致，返回一个不带有消息主体的 `304 Not Modified` 响应。浏览器收到后使用本地缓存。如果不一致，返回一个带有消息主体的 `200 OK` 响应。
- 常见场景：通常用于获取资源，保证资源已更新
- 当与 `If-None-Match` 一同出现时，会被覆盖，除非服务器不支持 `If-None-Match`。

### if-Unmodified-Since和If-Match

#### 不同点

- if-Unmodified-Since：是基于时间的条件请求头，服务器比较请求头里的 `If-Modified-Since` 时间和服务器上资源的上次修改时间。
- If-Match：基于内容的条件请求头，浏览器会在请求头中包含资源的ETag，可以有多个ETag值。

### 相同点

- 常见请求：put和delete。当资源匹配，返回200，说明资源没有被修改过，则允许操作，不匹配则返回 `412 Precondition Failed`。
- 常见场景：编辑资源，保证资源未被他人更新。
- 当与 `If-Match` 一同出现时，会被覆盖，除非服务器不支持 `If-None-Match`。

#### QA

**为什么Etag有多个值**

大多数情况， `If-None-Match` 请求头通常只包含一个ETag值。

- 多个版本的资源

这可以是因为客户端以不同方式请求同一资源（例如，不同的压缩或语言版本），或者资源多次更新，而客户端缓存了多个过时的版本。

- 负载平衡和数据中心复制

在分布式系统或使用CDN的情况下，同一资源可能有不同的ETag值，这取决于请求是发送到哪个服务节点或数据中心。客户端可能从多个位置获取资源副本，并希望确保其中的任何一个仍然有效。

- 客户端合并请求

某些客户端可能会试图在一个请求中校验多个资源，以减少网络往返次数。

- 客户端代理和同步工具

代理服务器或内容同步工具可能会代表多个客户端进行资源检索，同时持有不同ETag版本。
