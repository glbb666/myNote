[根据动画来学TCP的三次握手，四次挥手（简单了解）](<https://juejin.im/post/5b29d2c4e51d4558b80b1d8c#heading-0>)

[TCP的三次握手四次挥手（报文格式）](<https://juejin.im/post/5a0444d45188255ea95b66bc>)

[输入url之后（为什么三次握手四次挥手，2msl）](<https://juejin.im/post/5cc573c85188252e741ccbb6>)

## TCP报文格式

TCP/IP协议的详细信息参看《TCP/IP协议详解》三卷本。下面是TCP报文格式图：

![img](https://user-gold-cdn.xitu.io/2017/11/9/156658d59583ec0274d5e1f9a23ac2e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

上图中有几个字段需要重点介绍下：

（1）源端口：占16位，2字节，表示发送方的端口号。源IP地址和源端口同时使用，能够标识发送方的应用进程，便于报文返回。

（2）目的端口：占16位，2字节，表示接收方的端口号。目的IP和目的端口同时使用，能够用来标识接收方的应用进程。

（3）序号Seq：占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

（5）确认号Ack：占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

（6）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

（A）URG：紧急指针（urgent pointer）有效。

（B）ACK：确认序号有效。

（C）PSH：接收方应该尽快将这个报文交给应用层。

（D）RST：重置连接。

（E）SYN：发起一个新连接。

（F）FIN：释放一个连接。

#### 需要注意的是：

（A）不要将确认序号Ack与标志位中的ACK搞混了。
（B）确认方Ack=发起方Req+1，两端配对。

## TCP 三次握手

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。

![img](https://user-gold-cdn.xitu.io/2018/6/26/1643a1dd6df4813b?imageslim)



张三首先向李四招手(**syn**)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(**ack**)。张三看到李四微笑后确认了李四成功辨认出了自己(进入**estalished**状态)。

但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(**syn**)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(**ack**)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入**established**状态)。

于是两人加快步伐，走到了一起，相互拥抱。



![img](https://user-gold-cdn.xitu.io/2018/6/26/1643a1f3fa6c21b0?imageslim)



我们看到这个过程中一共是四个动作，张三招手--李四点头微笑--李四招手--张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(**syn+ack**)。于是四个动作就简化成了三个动作，张三招手--李四点头微笑并招手--张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。

我们看到有两个中间状态，**syn_sent**和**syn_rcvd**，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。**syn_sent**是主动打开方的「半打开」状态，**syn_rcvd**是被动打开方的「半打开」状态。**客户端是主动打开方，服务器是被动打开方**。

- syn_sent: syn package has been sent
- syn_rcvd: syn package has been received

💥注意：**tcp在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送**。

## TCP 四次挥手

TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。



![img](https://user-gold-cdn.xitu.io/2018/6/26/1643a20296de1ff0?imageslim)



之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，朝张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。



![img](https://user-gold-cdn.xitu.io/2018/6/26/1643b1147fbbc5e7?imageslim)

上面有一个非常特殊的状态`time_wait`，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。

它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的`time_wait`状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。

它的作用是**重传最后一个ack报文，确保对方可以收到**。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。

同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。

4分钟就是2个MSL，每个MSL是2分钟。MSL就是`maximium segment lifetime`——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。

四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从`fin_wait_1`状态直接进入到`time_wait`状态，跳过了`fin_wait_2`状态。

### 关于time_wait为什么是2个MSL

> MSL:最长报文段寿命

- 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，**并且会重启2MSL计时器**。

- 防止**已经失效的请求报文**出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使**本连接持续的时间内所产生的所有报文段都从网络中消失**。这样新的连接中不会出现旧连接的请求报文。

## 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
##### 三次握手

为了防止失效的连接请求报文段突然又传送到服务器，建立起新的连接，服务器会一直等待客户端发数据，因而导致服务器资源的浪费。

##### 四次挥手

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，**己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接**，因此，己方ACK和FIN一般都会分开发送。